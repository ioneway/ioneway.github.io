<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>iOneWay Blog</title><description>QQ:373850874. 欢迎加入。</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Tue, 16 Feb 2016 11:09:42 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Hit-Testing in iOS</title><description>&lt;p&gt;&lt;code&gt;Hit-testing&lt;/code&gt;翻译为中文是"命中测试"，是确定touch-point是否在一个View内的过程,最终命中的View被称为&lt;code&gt;hit-test view&lt;/code&gt;。iOS使用hit-testing来确定那一个UIView是用户手指下最靠前的且能够接收touch事件的view。hit-testing通过&lt;code&gt;反向前序深度优先&lt;/code&gt;算法来便利视图的层次结构，从而实现上述功能。&lt;/p&gt;

&lt;p&gt;在解释hit-testing 如何工作前，我们先要了解下hit-testing是在什么时候执行的。以下图分解了一个手指从触摸屏幕到离开屏幕的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-touch-event-flow.png" alt="hit-test-touch-event-flow"&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，每次手指触碰屏幕都会触发hit-testing, 并且hit-testing在各个视图和gesture recognizer接收UIEvent 事件之前触发。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;不清楚是什么原因，hit-testing会连续执行多次。并且，hit-test view 的hit-testing也会执行多次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;hit-testing完成后，最前方且能够接收事件的view就会被确定为hit-test view。hit-test view与各个阶段(begin,move,end,cancel)的触摸事件序列的UITouch对象相关联。hit-test view确定后，开始接收touch事件序列。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;需要了解的是，手指被移动到了hit-test view外，而移动到了另一个view内时，hit-test视图依旧会&lt;code&gt;接收整个&lt;/code&gt;touch事件的序列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description><link>http://localhost:2368/hit-testing-in-ios/</link><guid isPermaLink="false">5dd1d295-69d5-4499-916a-32480d5dcb11</guid><dc:creator>ioneway</dc:creator><pubDate>Tue, 16 Feb 2016 06:29:52 GMT</pubDate><content:encoded>&lt;p&gt;&lt;code&gt;Hit-testing&lt;/code&gt;翻译为中文是"命中测试"，是确定touch-point是否在一个View内的过程,最终命中的View被称为&lt;code&gt;hit-test view&lt;/code&gt;。iOS使用hit-testing来确定那一个UIView是用户手指下最靠前的且能够接收touch事件的view。hit-testing通过&lt;code&gt;反向前序深度优先&lt;/code&gt;算法来便利视图的层次结构，从而实现上述功能。&lt;/p&gt;

&lt;p&gt;在解释hit-testing 如何工作前，我们先要了解下hit-testing是在什么时候执行的。以下图分解了一个手指从触摸屏幕到离开屏幕的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-touch-event-flow.png" alt="hit-test-touch-event-flow"&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，每次手指触碰屏幕都会触发hit-testing, 并且hit-testing在各个视图和gesture recognizer接收UIEvent 事件之前触发。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;不清楚是什么原因，hit-testing会连续执行多次。并且，hit-test view 的hit-testing也会执行多次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;hit-testing完成后，最前方且能够接收事件的view就会被确定为hit-test view。hit-test view与各个阶段(begin,move,end,cancel)的触摸事件序列的UITouch对象相关联。hit-test view确定后，开始接收touch事件序列。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;需要了解的是，手指被移动到了hit-test view外，而移动到了另一个view内时，hit-test视图依旧会&lt;code&gt;接收整个&lt;/code&gt;touch事件的序列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;“The touch object is associated with its hit-test view for its lifetime, even if the touch later moves outside the view.”&lt;br&gt;
  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
  &lt;a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4"&gt;Event Handling Guide for iOS, iOS Developer Library&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如前所述，命中测试采用反向预定深度优先遍历（先访问根结点，然后遍历其子树由高到低的指标）。这种遍历可以减少遍历迭代次数，并在搜索到第一个包含touch-point的最深的子视图中停止搜索过程。这可能是因为一个视图总是在它的父视图之前渲染，而兄弟视图总是比在subviews具有较低索引的兄弟视图先渲染。这样，多个重叠的视图都包含一个touch-point时，在右子树的最深的视图是第一个被渲染的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Visually, the content of a subview obscures all or part of the content of its parent view. Each superview stores its subviews in an ordered array and the order in that array also affects the visibility of each subview. If two sibling subviews overlap each other, the one that was added last (or was moved to the end of the subview array) appears on top of the other.”&lt;br&gt;
  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html#//apple_ref/doc/uid/TP40009503-CH2-SW24"&gt;View Programming Guide for iOS, iOS Developer Library&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下图显示了一个视图层次树及其匹配的用户界面。从左到右树枝序列影响着subviews的数组顺序。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-view-hierarchy.png" alt="hit-test-view-hierarchy"&gt;&lt;/p&gt;

&lt;p&gt;图中可以看到，“VIewA”和“ViewB”和它们的子视图，“ViewA.2”和“View B.1”有重叠。但是“ViewB”在subViews中的索引值高于“ViewA”，“ViewB”和它的子视图会展现在“View A”和它的子视图之上。 因此，用户手指触摸 “View.b.1”与”View.A.2”重叠区域时，hit-testing返回“View.B.1”。&lt;/p&gt;

&lt;p&gt;通过应用深度优先反向前序遍历算法，各个视图的遍历路径如图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-depth-first-traversal.png" alt="hit-test-depth-first-traversal"&gt;&lt;/p&gt;

&lt;p&gt;遍历算法先发送hitTest:withEvent: 到UIWindow，UIWindow是视图层次结构的根视图。此方法返回的值是包含了触摸点的最靠前面的视图。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;下面的流程图说明了命中测试逻辑。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-flowchart.png" alt="hit-test-flowchart"&gt;&lt;/p&gt;

&lt;p&gt;以下代码是&lt;code&gt;hitTest:withEvent:&lt;/code&gt;可能的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    if ([self pointInside:point withEvent:event]) {
        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            if (hitTestView) {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法首先检查视图是否允许接收touch事件。如果一个View允许接收touch事件，则必须满足以下所有条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;self.hidden == NO&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;self. self.userInteractionEnabled = YES&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.alpha &amp;gt; 0.1&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointInside:withEvent: == YES&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当视图View允许接收touch事件时，该方法就会反向枚举它的子视图，然后逐个发送&lt;code&gt;hitTest:withEvent:&lt;/code&gt;消息，直到有一个子视图返回了nil。第一个返回非nil值的子视图就是这些子视图中最靠前且在touch-point下的视图。如果所有视图都返回nil或者该视图没有子视图则函数返回self.&lt;/p&gt;

&lt;p&gt;如果视图View不允许接收touch事件，该方法返回nil,而不需要在反向枚举。因此，hit-testing并不需要访问视图层次树上的所有视图。&lt;/p&gt;

&lt;h4 id="hittestwithevent"&gt;hitTest:withEvent:运用场景&lt;/h4&gt;

&lt;p&gt;hitTest:withEvent:可以被覆盖，当所有触摸事件阶段的所有阶段的触摸事件想要被一个视图处理重定向到另外一个视图。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;*注意: *&lt;/em&gt;因为hit-test仅仅在触摸事件顺序的第一次触摸事件（UITouchPhaseBegan phase(阶段)的触摸事件）发送给他的接收者之前，覆盖hitTest:withEvent:来重定向事件将会重定向所有phase的触摸事件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1.增加视图区域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;覆盖&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法的一个用途就是，当一个视图的触摸区域应该大于他的边界的时候。例如下面的插图显示了一个大小为20*20的视图。这个大小对于处理附近的触摸来说太小了。因此，他的触摸区域可以通过覆盖&lt;code&gt;hitTest:withEvent:&lt;/code&gt;在每个方向增加10。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-increase-touch-area.png" alt="hit-test-increase-touch-area"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    CGRect touchRect = CGRectInset(self.bounds, -10, -10);
    if (CGRectContainsPoint(touchRect, point)) {
        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            if (hitTestView) {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;为了能够正确的调用&lt;code&gt;hit-test&lt;/code&gt;，父视图的边界应该包含子视图希望触摸的区域，或者他的&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法也应该被覆盖来包含期望的触摸区域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2.传递触摸事件给下面的视图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有的时候对于一个视图忽略触摸事件并传递给下面的视图是很重要的。例如，假设一个透明的视图覆盖在应用内所有视图的最上面。覆盖层有子视图应该相应触摸事件的一些控件和按钮。但是触摸覆盖层的其他区域应该传递给覆盖层下面的视图。为了完成这个行为，覆盖层需要覆盖hitTest:withEvent:方法来返回包含触摸点的子视图中的一个，然后其他情况返回nil，包括覆盖层包含触摸点的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *hitTestView = [super hitTest:point withEvent:event];
    if (hitTestView == self) {
        hitTestView = nil;
    }
    return hitTestView;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.传递触摸事件给子视图&lt;/strong&gt;
一个不同的使用场景可能需要父视图重定向所有的触摸事件给他唯一的子视图。这个行为是有必要的当子视图部分占据他的父视图，但是子视图应该响应所有的触摸事件包括发生在父视图上的。例如，假设一个由一个父视图和一个&lt;code&gt;pagingEnabled&lt;/code&gt;设置为YES和&lt;code&gt;clipsToBounds&lt;/code&gt;设置为NO（为了实现传动带的效果）的&lt;code&gt;UIScrollView&lt;/code&gt;组成的图片浏览器：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-pass-touches-to-subviews.png" alt="hit-test-pass-touches-to-subviews"&gt;&lt;/p&gt;

&lt;p&gt;为了使&lt;code&gt;UIScrollView&lt;/code&gt;响应不发生在自己边界内但是在父视图的边界内的触摸事件，父视图的&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法应该像下面这样重写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *hitTestView = [super hitTest:point withEvent:event];
    if (hitTestView) {
        hitTestView = self.scrollView;
    }
    return hitTestView;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;如有问题请指正, 谢谢。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外一篇是一位大神的翻译，翻译了一半的时候才发现的，索性后半部分就直接粘贴了。&lt;br&gt;
大神翻译：&lt;a href="http://joywii.github.io/blog/2015/03/17/ioszhong-de-hit-testing/"&gt;http://joywii.github.io/blog/2015/03/17/ioszhong-de-hit-testing/&lt;/a&gt;&lt;br&gt;
原文地址：&lt;a href="http://smnh.me/hit-testing-in-ios/"&gt;http://smnh.me/hit-testing-in-ios/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>GitHubPages＋Ghost搭建博客</title><description>&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/headImg-3.jpg" alt="The Ghost Logo"&gt;&lt;/p&gt;

&lt;p&gt;对IT技术的学习也有不短的时间了。经常观看大神们的博客，对于他们博客不仅仅内容精彩，而且主题也很大气高端，所以也希望自己能有一个这样的博客。&lt;/p&gt;

&lt;p&gt;首先就是要选择博客平台，经过一番对比，最终选&lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;，因为其免费且专业，并且还有以下优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简易的配置，轻量级别系统，不需要数据库&lt;/li&gt;
&lt;li&gt;支持标记语言，如Markdown&lt;/li&gt;
&lt;li&gt;使用GitHub托管服务，免费300MB空间&lt;/li&gt;
&lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;li&gt;支持CDN，提升访问速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然GitHub Pages也有一些缺陷：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt; 模板系统，属于静态页面&lt;/li&gt;
&lt;li&gt;基于Git操作，需要有一定的动手能力&lt;/li&gt;
&lt;li&gt;动态性不好，没有评论系统，不过可以自己配置&lt;a href="https://disqus.com"&gt;Disqus&lt;/a&gt; 扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于GitHub Pages对Jekyll无缝支持。可是我在Jekyll主题市场里找了许久，没能找到我想要的那种看上去简洁，高端，并且适合程序员写技术博客的主题。于是就去借鉴大神们的选择，发现OneV‘cat的博客主题:&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;正是我所想要的那种。&lt;/p&gt;

&lt;p&gt;OneVcat中使用的博客程序是&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;是一种轻量级的动态博客，&lt;/p&gt;</description><link>http://localhost:2368/githubpages-ghostda-jian-bo-ke/</link><guid isPermaLink="false">cc9b5426-38d8-41e8-8022-8b289e963f66</guid><dc:creator>ioneway</dc:creator><pubDate>Sat, 30 Jan 2016 09:28:09 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/headImg-3.jpg" alt="The Ghost Logo"&gt;&lt;/p&gt;

&lt;p&gt;对IT技术的学习也有不短的时间了。经常观看大神们的博客，对于他们博客不仅仅内容精彩，而且主题也很大气高端，所以也希望自己能有一个这样的博客。&lt;/p&gt;

&lt;p&gt;首先就是要选择博客平台，经过一番对比，最终选&lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;，因为其免费且专业，并且还有以下优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简易的配置，轻量级别系统，不需要数据库&lt;/li&gt;
&lt;li&gt;支持标记语言，如Markdown&lt;/li&gt;
&lt;li&gt;使用GitHub托管服务，免费300MB空间&lt;/li&gt;
&lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;li&gt;支持CDN，提升访问速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然GitHub Pages也有一些缺陷：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt; 模板系统，属于静态页面&lt;/li&gt;
&lt;li&gt;基于Git操作，需要有一定的动手能力&lt;/li&gt;
&lt;li&gt;动态性不好，没有评论系统，不过可以自己配置&lt;a href="https://disqus.com"&gt;Disqus&lt;/a&gt; 扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于GitHub Pages对Jekyll无缝支持。可是我在Jekyll主题市场里找了许久，没能找到我想要的那种看上去简洁，高端，并且适合程序员写技术博客的主题。于是就去借鉴大神们的选择，发现OneV‘cat的博客主题:&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;正是我所想要的那种。&lt;/p&gt;

&lt;p&gt;OneVcat中使用的博客程序是&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;是一种轻量级的动态博客，有一个管理后台，可以直接写作和管理博客。本质上和WordPress是相通的，只是 Ghost 搭建在 Node.js 环境上，轻量，快速，简洁。&lt;/p&gt;

&lt;p&gt;所以我最终选择了&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，因为其高颜值和强大的后台管理,另外还有一个原因就是它还有&lt;a href="http://www.ghostchina.com"&gt;中文版Ghost&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 技术栈简要解析
把 &lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 的结构厘清，其实蛮简单，特别是使用官方已经编译好的 &lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 压缩包解压后进行二次开发的话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ghost 的页面使用的是 &lt;code&gt;Handlebars.js&lt;/code&gt; 前端模板引擎，页面总数在 10 个左右。页面采用&lt;code&gt;引入/调用&lt;/code&gt;方式，就是把常规的 HTML 结构，譬如 &lt;code&gt;meta&lt;/code&gt; 头信息、&lt;code&gt;header&lt;/code&gt;、&lt;code&gt;footer&lt;/code&gt; 等常用且可以复用的 HTML 页面结构，给独立成一个个模板文件，而在其他诸如&lt;code&gt;单篇博文页、博主个人主页&lt;/code&gt;等页面模板文件内，引用上面的独立模板文件。譬如在单篇博文页内引入 meta 头信息模板文件，就可以达到一处编写,处处调用的类似&lt;code&gt;变量调用/引入&lt;/code&gt;的概念。&lt;strong&gt;前端模板引擎的出现，给前端开发人员缩短开发周期起到了不可或缺的作用&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于GitHub Pages只支持静态博客，而Ghost却是动态的。所谓动态博客，需要服务器来支持数据输出。而静态页面，就是诸如&lt;code&gt;HTML&lt;/code&gt;,&lt;code&gt;XML&lt;/code&gt;等标记语言写好结构，用&lt;code&gt;css&lt;/code&gt;描述好表现样式，用&lt;code&gt;JavaScript&lt;/code&gt;写好了交互逻辑的，理论上不再接受后端服务器数据输出而动态修改的页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;简而言之，静态页面是死的，动态页面是活的。&lt;/em&gt;&lt;/strong&gt;对于Github Pages这样仅仅支持静态网站/页面的托管服务而言，怎么搞定Ghost的托管呢？&lt;/p&gt;

&lt;h3 id="buster"&gt;&lt;strong&gt;开源项目&lt;code&gt;Buster&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Buster是&lt;code&gt;Python&lt;/code&gt;语言写的一个&lt;strong&gt;文件路径遍历器&lt;/strong&gt;。通过调用&lt;code&gt;Wget&lt;/code&gt;把Ghost中用到的图片，字体，CSS，javaScript等静态资源统一复制到一个新的文件夹(同时此文件夹可以作为Github Pages的仓库)，然后相应地修改HTML文件内引用的静态文件的路径，使之最终生效。Buster由Misiur提供：&lt;a href="https://github.com/Misiur/buster"&gt;https://github.com/Misiur/buster&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=""&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;1, &lt;a href="https://nodejs.org/en/download/releases"&gt;Node.js&lt;/a&gt;：Ghost依赖Node.js。 建议安装v0.10.26版本。&lt;/p&gt;
  
  &lt;p&gt;2, &lt;a href="http://git-scm.com/download"&gt;Git&lt;/a&gt;: 用于克隆项目到本地，部署、提交项目到 Github。Mac OSX 自带。&lt;/p&gt;
  
  &lt;p&gt;3, &lt;a href="https://www.python.org/downloads/"&gt;Python&lt;/a&gt;：用于执行Buster工具，Mac OSX自带。&lt;/p&gt;
  
  &lt;p&gt;4, &lt;a href="https://github.com/pypa/pip"&gt;pip&lt;/a&gt;: Python包管理工具，用于安装Buster工具。&lt;/p&gt;
  
  &lt;p&gt;5, &lt;a href="https://github.com/Misiur/buster"&gt;Buster&lt;/a&gt;: 用于将Ghost动态页面转换为静态页面。&lt;/p&gt;
  
  &lt;p&gt;6, &lt;a href="https://github.com/diancloud/Ghost"&gt;Ghost中文版&lt;/a&gt;：建议安装中文版，因为中文版已经包含了所有需要的插件。&lt;/p&gt;
  
  &lt;p&gt;7, &lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;：一款简洁高端大气的ghost博客主题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=""&gt;&lt;strong&gt;具体步骤&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1，搭建环境&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装node.js，建议v0.10.6版本&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;brew update  
brew install nvm //安装nvm  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在(~/.bashrc, ~/.profile, or ~/.zshrc)中添加如下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#For NVM
export NVM_DIR=~/.nvm  
source $(brew --prefix nvm)/nvm.sh  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用nvm安装node.js &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nvm install v0.10.6  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入用户Documents目录,并新建文件夹：GithubPages_ZH.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-Shell"&gt;cd ~/Documents &amp;amp;&amp;amp; mkdir GithubPages_ZH  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH目录，并下载&lt;a href="https://github.com/diancloud/Ghost"&gt;Ghost中文版&lt;/a&gt;，并将其命名为Ghost。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd GithubPages_ZH  
git clone https://github.com/diancloud/Ghost.git  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH/Ghost/content/themes/, 然后下载&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;主题.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd Ghost/content/themes/  
git clone https://github.com/onevcat/vno.git  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH/Ghost 启动Ghost服务&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;nvm use default 0.10.6  
npm start  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器打开:&lt;a href="http://localhost:2368/ghost"&gt;http://localhost:2368/ghost&lt;/a&gt;进入后台管理页面。注册一个管理员帐号，并记住帐号密码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置主题
点击左侧栏“全局设置”按钮，进入设置页面，下滑到最下方，主题：选择vno主题，并保存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装pip:Python包管理工具&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo easy_install pip  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装Buster: 执行以下命令&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;pip install git+https://github.com/Misiur/buster  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登陆Github 创建仓库，仓库名称&lt;code&gt;必须是&lt;/code&gt;：&lt;code&gt;[your－username].github.io&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终端执行以下命令：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd ~/GithubPages_ZH  
buster setup -gh-repo=\  
"https://github.com/&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git"
//这里会要求输入github帐号密码。
buster generate //产生静态文件，此时会在当前文件夹下产生static文件夹。  
buster deploy  //发布  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在static文件夹下添加文件：.gitignore文件，用于在提交github时忽略部分文件。在.gitignore中添加如下内容：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# vim ~tmp files
*.swp
*.un~

# ignore bourbon install so that it is the latest build
# for developers that need it
assets/scss/bourbon/*

# ignore the sass-cache/
.sass-cache/*
**/.sass-cache/*

### OSX ###
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear on external disk
.Spotlight-V100
.Trashes

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder  
Temporary Items  
.apdisk
config.codekit  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;你需要根据自己的实际情况对主题中各个按钮的点击链接以及图片进行设置，具体请参考链接：&lt;a href="https://github.com/onevcat/vno"&gt;https://github.com/onevcat/vno&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，Ghost博客搭建完成。之后每次跟新博客时：需要点击编辑窗口右上方的更新按钮，然后终端执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//在GithubPages_ZH下执行
//不需要再次执行Buster setup 命令
buster generate  
buster deploy  //发布  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="ghost"&gt;Ghost 相关资源推荐&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;各种 Ghost 主题：&lt;a href="http://www.allghostthemes.com"&gt;http://www.allghostthemes.com&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;官方主题市场：&lt;a href="http://marketplace.ghost.org"&gt;http://marketplace.ghost.org&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="ghost"&gt;&lt;strong&gt;Ghost高级设置&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;添加评论系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;ol&gt;
&lt;li&gt;注册&lt;a href="http://duoshuo.com"&gt;多说&lt;/a&gt;帐号,点击“安装”按钮并填写相关设置;  &lt;/li&gt;
&lt;li&gt;复制稳定版通用代码，黏贴在：&lt;code&gt;Ghost/content/themes/casper/post.hbs&lt;/code&gt;模板文件的 ｀｀&lt;code&gt;{{/post}}&lt;/code&gt; 标签前，并保存。 &lt;br&gt;
如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-22-43.png" alt="duoshuo_code"&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意&lt;/code&gt;将其中中文字符分别替换为：&lt;code&gt;{{id}}&lt;/code&gt;， &lt;code&gt;{{title}}&lt;/code&gt;，&lt;code&gt;ioneway.github.io{{url}}&lt;/code&gt;. 其中&lt;code&gt;ioneway.github.io&lt;/code&gt;替换为你的域名。
  
  最终粘贴的代码如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 多说评论框 start --&amp;gt;  
    &amp;lt;div class="ds-thread" data-thread-key="{{id}}" data-title="{{title}}" data-url="ioneway.github.io{{url}}"&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!-- 多说评论框 end --&amp;gt;  
&amp;lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&amp;gt;  
&amp;lt;script type="text/javascript"&amp;gt;  
var duoshuoQuery = {short_name:"abcbytr"};  
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    &amp;lt;/script&amp;gt;
&amp;lt;!-- 多说公共JS代码 end --&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登陆多说，进入设置页面，基本设置。正确填写以下两项：首页网址：&lt;a href="http://ioneway.github.io"&gt;http://ioneway.github.io&lt;/a&gt;
，首选域名：选择最后一项：“将网址显示为ioneway.github.io”。保存。&lt;/p&gt;

&lt;p&gt;如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-41-14.png" alt="duoshuo_setting"&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2，添加 CNZZ 统计&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1， 注册&lt;a href="http://www.cnzz.com"&gt;CNZZ&lt;/a&gt; &lt;br&gt;
2， 登陆&lt;a href="http://www.cnzz.com"&gt;CNZZ&lt;/a&gt; &lt;code&gt;站点设置&lt;/code&gt;, &lt;code&gt;获取代码&lt;/code&gt; 选择其中一种，并复制代码 &lt;br&gt;
如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-54-11.png" alt="duoshuo_setting"&gt;&lt;/p&gt;

&lt;p&gt;3， 终端输入命令&lt;code&gt;npm start&lt;/code&gt;开启服务 &lt;br&gt;
4， 浏览器输入&lt;a href="http://localhost:2368/ghost"&gt;http://localhost:2368/ghost&lt;/a&gt;进入后台管理。 &lt;br&gt;
5. 点击左侧边栏：&lt;code&gt;插入代码&lt;/code&gt;，将复制的代码粘贴在&lt;code&gt;页脚&lt;/code&gt;框中，保存。&lt;/p&gt;

&lt;p&gt;至此，你的博客就有了基本完整的功能了，你可以登录多说和&lt;a href="http://www.cnzz.com"&gt;CNZZ&lt;/a&gt;管理你的站点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如有遗漏，欢迎指正。谢谢。&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title>欢迎使用 Ghost 博客系统</title><description>&lt;p&gt;Yeah，博客上线了！这篇文章的目的是向你介绍 Ghost 编辑器并帮你快速上手。通过 &lt;code&gt;&amp;lt;your blog URL&amp;gt;/ghost/&lt;/code&gt; 链接就可以登录系统后台管理你的博客内容了。当你进入后台，你就能看到左侧文章列表处列出的这篇文章，右侧就是这篇文章的预览效果。点击预览栏右上角的铅笔图标就能进入内容编辑页面。 &lt;/p&gt;

&lt;h2 id=""&gt;快速入门&lt;/h2&gt;

&lt;p&gt;Ghost 使用 Markdown 语法书写内容。简单来说，Markdown 就是一种简化的书写格式！&lt;/p&gt;

&lt;p&gt;用 Markdown 语法写作是很容易的。在编辑界面的左侧就是你写作的地方。在你认为需要的时候，可以使用以下这些语法来格式化你的内容。例如下面这个无序列表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Item number one&lt;/li&gt;
&lt;li&gt;Item number two
&lt;ul&gt;&lt;li&gt;A nested item&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A final item&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还可以是有序列表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Remember to buy some milk&lt;/li&gt;&lt;/ol&gt;</description><link>http://localhost:2368/welcome-to-ghost/</link><guid isPermaLink="false">9dddcac0-0676-4542-aa19-7d7902bd1962</guid><category>系统简介</category><dc:creator>ioneway</dc:creator><pubDate>Thu, 28 Jan 2016 16:36:59 GMT</pubDate><content:encoded>&lt;p&gt;Yeah，博客上线了！这篇文章的目的是向你介绍 Ghost 编辑器并帮你快速上手。通过 &lt;code&gt;&amp;lt;your blog URL&amp;gt;/ghost/&lt;/code&gt; 链接就可以登录系统后台管理你的博客内容了。当你进入后台，你就能看到左侧文章列表处列出的这篇文章，右侧就是这篇文章的预览效果。点击预览栏右上角的铅笔图标就能进入内容编辑页面。 &lt;/p&gt;

&lt;h2 id=""&gt;快速入门&lt;/h2&gt;

&lt;p&gt;Ghost 使用 Markdown 语法书写内容。简单来说，Markdown 就是一种简化的书写格式！&lt;/p&gt;

&lt;p&gt;用 Markdown 语法写作是很容易的。在编辑界面的左侧就是你写作的地方。在你认为需要的时候，可以使用以下这些语法来格式化你的内容。例如下面这个无序列表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Item number one&lt;/li&gt;
&lt;li&gt;Item number two
&lt;ul&gt;&lt;li&gt;A nested item&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A final item&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还可以是有序列表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Remember to buy some milk  &lt;/li&gt;
&lt;li&gt;Drink the milk  &lt;/li&gt;
&lt;li&gt;Tweet that I remembered to buy the milk, and drank it&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=""&gt;链接&lt;/h3&gt;

&lt;p&gt;如果要链接其它页面，可以直接把页面的 URL 粘贴过来，例如 &lt;a href="http://www.ghostchina.com"&gt;http://www.ghostchina.com&lt;/a&gt; - 会被自动识别为链接。但是，如果你想自定义链接文本，可以像这样： &lt;a href="http://www.ghostchina.com"&gt;Ghost 中文网&lt;/a&gt;。很简单吧！&lt;/p&gt;

&lt;h3 id=""&gt;图片&lt;/h3&gt;

&lt;p&gt;插入图片也没问题！前提是你事先知道图片的 URL，然后像下面这样：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://static.ghostchina.com/image/3/fe/34a9831916be9db1381ecb320491e.png" alt="The Ghost Logo"&gt;&lt;/p&gt;

&lt;p&gt;如果图片在本地的硬盘里怎么办？也很简单！像下面这样书写就能为图片预留一个位置，然后你可以继续写作，回头再通过拖拽的方式把图片上传到服务器上。&lt;/p&gt;

&lt;h3 id=""&gt;引用&lt;/h3&gt;

&lt;p&gt;有些时候我们需要引用别人说的话，可以这样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Wisdomous - it's definitely a word.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=""&gt;代码&lt;/h3&gt;

&lt;p&gt;或许你是个码农，需要贴一些代码到文章里，可以通过两个引号（Tab 键上面的那个键）加入行内代码 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;。如果需要加入大段的代码，可以在代码前加 4 个空格缩进，这就是 Markdown 的语法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.awesome-thing {
    display: block;
    width: 100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=""&gt;分割线&lt;/h3&gt;

&lt;p&gt;在任一新行输入 3 个或更多的短横线（减号）就是一条分隔线了。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=""&gt;高级用法&lt;/h3&gt;

&lt;p&gt;Markdown 还有一个特别用法，就是在你需要的时候可以直接书写 HTML 代码。&lt;/p&gt;

&lt;p&gt;&lt;input type="text" placeholder="这是个输入框！"&gt;&lt;/p&gt;

&lt;p&gt;只要掌握了上面的这些介绍，你就已经入门了！继续写作吧！&lt;/p&gt;</content:encoded></item></channel></rss>