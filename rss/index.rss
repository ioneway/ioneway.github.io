<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>iOneWay Blog</title><description>QQ:373850874. 欢迎加入。</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Thu, 18 Feb 2016 06:59:09 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>iOS 7 SDK: 多任务的改进</title><description>&lt;p&gt;原文地址：&lt;a href="http://code.tutsplus.com/tutorials/ios-7-sdk-multitasking-enhancements--mobile-20295"&gt;http://code.tutsplus.com/tutorials/ios-7-sdk-multitasking-enhancements--mobile-20295&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇教程向我们介绍iOS7 SDK中多任务的改进，具体来说，你将了解到Background Fetch, Remote Notifications, 和Background Transfer Service APIs。&lt;/p&gt;

&lt;h2 id=""&gt;&lt;strong&gt;多任务概述&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;iOS7中，Apple新加了3类新的mutltitasking APIs：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Background Fetch&lt;/li&gt;
&lt;li&gt;Remote Notifications&lt;/li&gt;
&lt;li&gt;Background Transfer Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些APIs可以使程序员更充分的利用硬件特性完成多任务，以向用户提供跟好的用户体验。本教程会教你跟多关于上述三个改进，以及什么时候该使用他们。&lt;/p&gt;

&lt;h1 id="backgroundfetch"&gt;Background Fetch&lt;/h1&gt;

&lt;p&gt;为了使Background Fetch API更加易于理解，想像一下你想建立一个新闻类app，该类应用
的内容由网络提供，会有一个重要的特点就是每次用户打开app都要跟新内容。&lt;/p&gt;

&lt;p&gt;在iOS7之前，开发者会在app启动的时候获取跟新内容。这样做有一个缺陷，就是用户在需要在启动app后等待一段时间，等待时间也要受到手机的连接速度的影响。试想一下，如果用户在一两个星期没有使用后，通过蜂窝网打开app会需要等多久。&lt;/p&gt;</description><link>http://localhost:2368/ios-7-sdk-duo-ren-wu-de-gai-jin/</link><guid isPermaLink="false">0dcc7a07-1f8a-441e-9289-581c0cf5349f</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 18 Feb 2016 06:55:29 GMT</pubDate><content:encoded>&lt;p&gt;原文地址：&lt;a href="http://code.tutsplus.com/tutorials/ios-7-sdk-multitasking-enhancements--mobile-20295"&gt;http://code.tutsplus.com/tutorials/ios-7-sdk-multitasking-enhancements--mobile-20295&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇教程向我们介绍iOS7 SDK中多任务的改进，具体来说，你将了解到Background Fetch, Remote Notifications, 和Background Transfer Service APIs。&lt;/p&gt;

&lt;h2 id=""&gt;&lt;strong&gt;多任务概述&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;iOS7中，Apple新加了3类新的mutltitasking APIs：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Background Fetch&lt;/li&gt;
&lt;li&gt;Remote Notifications&lt;/li&gt;
&lt;li&gt;Background Transfer Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些APIs可以使程序员更充分的利用硬件特性完成多任务，以向用户提供跟好的用户体验。本教程会教你跟多关于上述三个改进，以及什么时候该使用他们。&lt;/p&gt;

&lt;h1 id="backgroundfetch"&gt;Background Fetch&lt;/h1&gt;

&lt;p&gt;为了使Background Fetch API更加易于理解，想像一下你想建立一个新闻类app，该类应用
的内容由网络提供，会有一个重要的特点就是每次用户打开app都要跟新内容。&lt;/p&gt;

&lt;p&gt;在iOS7之前，开发者会在app启动的时候获取跟新内容。这样做有一个缺陷，就是用户在需要在启动app后等待一段时间，等待时间也要受到手机的连接速度的影响。试想一下，如果用户在一两个星期没有使用后，通过蜂窝网打开app会需要等多久。这显然不是开发者所希望的，因为这会影响用户体验。&lt;/p&gt;

&lt;p&gt;在iOS7及其之后，这种情况会得到彻底改变。使用Background Fetch API可以使app在后台被动下载跟新内容。iOS会唤醒app，并分配后台时间，当app完成跟新后就又会回到休眠状态。当然，当发生跟新时，用户不会接到通知。当他们返回应用的时候，他们将看到的是跟新后的内容。&lt;/p&gt;

&lt;p&gt;更新过程可以在任一由程序员或由系统预定的时间间隔发生。如果你选择自定义间隔，苹果建议你应该设置更大的间隔，而不是过于平凡的后台获取。太小的间隔，太频繁的跟新会浪费电池和系统资源。如果采用系统设置的时间间隔，那么iOS7会自己更具情况设置。它将会更具用户启动这款app频率以及启动的时间来预测。例如，一款news app，用户一般启动它的时间在每天下午，那么iOS系统会决定应用程序应该在平时下午启动应用时间之前的一段时间进行跟新。非常的智能且节省。&lt;/p&gt;

&lt;p&gt;以上描述的Background Fetch包括以下三步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开Background Fetch capability  &lt;/li&gt;
&lt;li&gt;设置最小间隔  &lt;/li&gt;
&lt;li&gt;执行代理方法：&lt;code&gt;application:performFetchWithCompletionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来了解一下跟详细的内容。
正如我刚才提到的第一步：打开Background Fetch capability，可以通过Xcode5来完成有两种方式。第一种方式是通过.plist文件，你需要添加一个key为：Required background modes，value为“fetch”的。像下面这样：
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_1_plist_fetch.png" alt="gt7_1_plist_fetch.png"&gt;&lt;/p&gt;

&lt;p&gt;下面的步骤是另外一个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击Xcode左侧栏目的project;&lt;/li&gt;
&lt;li&gt;点击中间窗口的&lt;strong&gt;Capabilities&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;选择Background Fetch单选框
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_2_capabilities_fetch.png" alt="gt7_2_capabilities_fetch.png"&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下，初始间隔值被设定为：&lt;code&gt;UIApplicationBackgroundFetchIntervalNever&lt;/code&gt;,这意味着Background Fetch将永远不会执行。如果不改变该值，那么将不会起作用。你需要在&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt; 重新设置该值。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Objc"&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];

    return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值：UIApplicationBackgroundFetchIntervalMinimum是由系统控制间隔时间且是允许的最小的间隔时间。当然，你也可以通过以上方法设置一个&lt;code&gt;NSTimeInterval&lt;/code&gt;类型的值作为自定义的时间间隔。然而，除非必要，最好还是应该由系统控制Background Fetch的执行时间间隔。但是，即便你设置了&lt;code&gt;UIApplicationBackgroundFetchIntervalMinimum&lt;/code&gt;,你也要清楚的知道，它不是一种绝对的时序安排，它更像是一种建议，iOS系统会尽可能的这么做，但是也会依据当前的可用系统资源来决定。所以Background Fetch的执行次数会少于或者多于我们的预期。&lt;/p&gt;

&lt;p&gt;最后一步是实现新添加的方法：&lt;code&gt;application:performFetchWithCompletionHandler:&lt;/code&gt; 当background fetch执行的时候，该方法开始执行。该方法的回调函数会收到以下三种值：
1. &lt;code&gt;UIBackgroundFetchResultNewData:&lt;/code&gt;如果获取到了新内容 &lt;br&gt;
2. &lt;code&gt;UIBackgroundFetchResultNoData:&lt;/code&gt;没有获取到内容 &lt;br&gt;
3. &lt;code&gt;UIBackgroundFetchResultFailed:&lt;/code&gt;发生错误，获取失败&lt;/p&gt;

&lt;p&gt;请看以下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;-(void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{

    // Call or write any code necessary to get new data, process it and update the UI.

    // The logic for informing iOS about the fetch results in plain language:
    if (/** NEW DATA EXISTS AND WAS SUCCESSFULLY PROCESSED **/) {
        completionHandler(UIBackgroundFetchResultNewData);
    }

    if (/** NO NEW DATA EXISTS **/) {
        completionHandler(UIBackgroundFetchResultNoData);
    }

    if (/** ANY ERROR OCCURS **/) {
        completionHandler(UIBackgroundFetchResultFailed);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在新数据被发现时，你必须进行必要的用户界面跟新。必须立刻更新用户界面的原因有两个：1》用户应该在打开应用的时候可以看到更新的内容，而无需任何等待(包括加载时间的等待)；2》app的快照也会保持为更新状态。&lt;/p&gt;

&lt;p&gt;这里有几点需要你注意：首先，当app开始从后台执行任务，它只有30秒的时间完成必须的任务。如果30秒时间到了，app将会被再次挂起。如果app需要跟多的时间(比如媒体下载)来执行任务，你应该使用Background Transfer Service API来执行后台获取。我们之后会讲到这个。&lt;/p&gt;

&lt;p&gt;你在做好了Background Fetch的编码后，APPle提供了两种方法来测试你的Background Fetch功能：&lt;/p&gt;

&lt;p&gt;第一种方法有以下步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;像往常一样在模拟器上运行app&lt;/li&gt;
&lt;li&gt;当app运行后，回到Xcode&lt;/li&gt;
&lt;li&gt;点击菜单栏：Debug &gt; Simulate Background Fetch &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种方法在app运行时候测试API非常有效。第二种方式要复杂多，但是他允许你的app在后台时测试：参考以下步骤：
* 打开Schemes列表，点击Manage Schemes...选项。
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_3_manage_schemes.png" alt="gt7_3_manage_schemes.png"&gt;
* 确定选择了当前Scheme，然后复制它：点击窗口下方的齿轮按钮，选择Duplicate
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_4_duplicate_scheme.png" alt="gt7_4_duplicate_scheme.png"&gt;
* 为复制的Scheme设置一个名称。
* 选择左侧列表的&lt;strong&gt;Run&lt;/strong&gt;，然后点击&lt;strong&gt;Options&lt;/strong&gt;。
* 选择&lt;em&gt;*Launch due to a background fetch event *&lt;/em&gt;单选框，点击OK。
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_5_scheme2.png" alt="gt7_5_scheme2.png"&gt;
* 运行复制的Scheme。&lt;/p&gt;

&lt;p&gt;Background fetch只是用与非关键的更新，所以它们跟新的时间不确定。对于关键的更新，请查看 Remote Notifications 部分的内容。一般Background fetch是适合那些希望无缝地管理内容的app，比如展示类的应用：如：新闻，社交网络，天气，图片共享等。&lt;/p&gt;

&lt;h1 id="remotenotifications"&gt;Remote Notifications&lt;/h1&gt;

&lt;p&gt;试想一下，我们要构建一个提供书面和视屏教程的应用。我们假设用户每个月会下载新的视屏教程2到3次。所以，我们该如何让用户知道有新的视屏发布呢？我们不能采用 background fetch API或者类似的东西，因为这会浪费硬件资源和无意义的数据请求。我们也无法知道什么时候一个新的视屏教程会发布。因此，我们需要使用Push Notifications，因此每次有新的内容的时候，我们可以简单地通知用户。我们也希望用户能频繁的启动app并下载新的内容，如果内容很大，他们将需要等很长的时间。因此，当有新内容可用的时候，用户如何才能保持最新的内容而又不需要等待呢？&lt;/p&gt;

&lt;p&gt;Remote Notifications可以在这里派上作用，Remote Notifications实际上是静默通知，也就是说发送通知，却又不让用户知道通知的存在。当一个新的Remote Notifications到达，系统静默地唤醒app，所以此时app可以执行notification。然后app负责启动下载进程更新内容.当完成下载后，本地通知发送给用户。当应用启动时，新的内容已经在等待用户了。&lt;/p&gt;

&lt;p&gt;就像Background Fetch一样，Remote Notifications目的是消除在下载新内容和上传数据时面对的长时间等待的问题。他们的APIs都是在后台线程工作，完成工作后通知用户。然而，Remote Notifications更加适合用在不太频繁的更新或者是非常影响用户体验的情况下。&lt;/p&gt;

&lt;p&gt;要在APP中使用Remote Notifications，你必须先激活它们。你可以通过.plist文件或者Capabilities Tab来完成。如果你要使用.plist文件的方式，你需要添加key：&lt;strong&gt;Required Background&lt;/strong&gt;，value： &lt;strong&gt;remote-notification&lt;/strong&gt;， 像下面这样：
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_6_plist_remote.png" alt="gt7_6_plist_remote.png"&gt;&lt;/p&gt;

&lt;p&gt;要使用Capabilities tab方式，需要以下步骤：
* 点击左侧上面的project
* 点击中间窗口的&lt;strong&gt;Capabilities&lt;/strong&gt;导航条
* 打开&lt;strong&gt;Background Modes&lt;/strong&gt;选项，选择&lt;strong&gt;Remote Notifications&lt;/strong&gt;单选框
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_7_capabilities_remote.png" alt="gt7_7_capabilities_remote.png"&gt;&lt;/p&gt;

&lt;p&gt;下一步是实现方法：&lt;code&gt;application:didReceiveRemoteNotification:fetchCompletionHandler:&lt;/code&gt;. 该方法会在新通知到达的时候调用。使用完成回调方法来通知iOS获取数据的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{

    // Call or write any code necessary to download new data.

    completionHandler(UIBackgroundFetchResultNewData);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想要静默通知非常简单。在notification载体，你只需要加入一句：&lt;code&gt;code-available: 1&lt;/code&gt; 就会忽略任何形式的提示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aps{  
   content-available: 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在一般情况下，一切与后台获取工作时，其有效期也适用于此。
例如，你最多只有30秒下载新的内容并在app休眠前利用以上方法通知用户，
如果新内容需要更多的下载时间，那么需要考虑使用Background Transfer Service API。&lt;/p&gt;

&lt;p&gt;请注意，苹果控制着remote notification(silent push notifications) 发送的频率，如果频率正常，那么将正常传送。然而如果频率过高，APNs会存储它们，稍后发送。请确保你合理使用远程通知。&lt;/p&gt;

&lt;h2 id="backgroundtransferservice"&gt;Background Transfer Service&lt;/h2&gt;

&lt;p&gt;iOS7另一个重要功能：&lt;strong&gt;Background Transfer Service API&lt;/strong&gt;. 过去，发送或者接收大块数据并不是那么容易，主要是由于运行时间和传输数据的管控的限制。app可以在前台完成大部分的上传和下载数据的需求。然后，iOS7的到来，事情将完全不同，执行后台任务时，app可以有更大的自由。首先，使用Background Transfer Service，应用可以有足够的时间去完成传输任务，而它们是处于前台还是后台无关紧要。时间的限制不在存在。Background Transfer Service会负责管理上传和下载数据。即使应用没有在运行，iOS系统也会唤醒它做出响应。&lt;/p&gt;

&lt;p&gt;Background Transfer Service是以NSURLSession类为基础的，NSURLSession在iOS7时出现。该类通过HTTP和HTTPS传输数据，还提供了后台网络传输相关任务的能力。它背后的思想很简单，它时基于会话(session)的，一个会话管理相关数据的传输任务。有各种可用的session类型，但是我们这里需要了解的是后台sessions，而且它总是工作在系统创建的单独的线程上。后台会话类型包括：&lt;code&gt;NSURLSessionDownloadTask&lt;/code&gt;和&lt;code&gt;NSURLSes`ssionUploadTask&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;另一个值得注意的事情是： background transfers 分为两个模式：discretionary和non-discretionary。Non-discretionary只能初始化在app前台。但是有一个选项可以更具应用的需要设置为discretionary状态。相比之下Discretionary transfers 更加好用，因为这些允许操作系统实现更高效的能量管理。当然on discretionary transfer有一个限制就是只能WI-FI下传输。后台传输尝尝使用discretionary模式。&lt;/p&gt;

&lt;p&gt;代理方法：&lt;code&gt;application:handleEventsForBackgroundURLSession:completionHandler:&lt;/code&gt;在后台传输完成后被调用来完成回调。&lt;/p&gt;

&lt;h3 id=""&gt;&lt;strong&gt;未完，待续&lt;/strong&gt;&lt;/h3&gt;</content:encoded></item><item><title>如何检测任意view的subviews的关系树</title><description>&lt;p&gt;原文地址：&lt;a href="http://www.glimsoft.com/01/07/how-to-inspect-subviews-hierarchy-of-any-uiview/"&gt;http://www.glimsoft.com/01/07/how-to-inspect-subviews-hierarchy-of-any-uiview/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本程序设计教程（或指南，如果你希望如此），我要解释一个简单的方式打印出任何UIView整个子视图层次（子类）。我们要通过创建UIView类，并添加一个递归方法来查看整个树结构。&lt;/p&gt;

&lt;p&gt;现在，可能有人想知道什么是‘category’：它是一种不需要继承任何类来向类中添加方法的一种简洁方式。想了解更多可以参考官方文档：&lt;a href="http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/objectivec/chapters/occategories.html"&gt;documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在某些情况下，当你在寻找一些基础的东西，比如MKMapView的组成；为了修改某些标签，等等，我觉得这种情况很多，所以没有必要再举例了。&lt;/p&gt;

&lt;p&gt;以下是我们的一个category(file UIView+printSubviews.h)：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;


@interface UIView (PrintSubviews)

- (void)printSubviewsWithIndentation:(int)indentation;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Objective-C的Category声明十分简单且重要。更重要的是我们的方法可以在任何UIView及其子类(&lt;/p&gt;</description><link>http://localhost:2368/ru-he-jian-ce-ren-yi-viewde-subviewsde-guan-xi-shu/</link><guid isPermaLink="false">42123b1c-bd2b-401f-8693-add057cec231</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 18 Feb 2016 06:47:50 GMT</pubDate><content:encoded>&lt;p&gt;原文地址：&lt;a href="http://www.glimsoft.com/01/07/how-to-inspect-subviews-hierarchy-of-any-uiview/"&gt;http://www.glimsoft.com/01/07/how-to-inspect-subviews-hierarchy-of-any-uiview/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本程序设计教程（或指南，如果你希望如此），我要解释一个简单的方式打印出任何UIView整个子视图层次（子类）。我们要通过创建UIView类，并添加一个递归方法来查看整个树结构。&lt;/p&gt;

&lt;p&gt;现在，可能有人想知道什么是‘category’：它是一种不需要继承任何类来向类中添加方法的一种简洁方式。想了解更多可以参考官方文档：&lt;a href="http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/objectivec/chapters/occategories.html"&gt;documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在某些情况下，当你在寻找一些基础的东西，比如MKMapView的组成；为了修改某些标签，等等，我觉得这种情况很多，所以没有必要再举例了。&lt;/p&gt;

&lt;p&gt;以下是我们的一个category(file UIView+printSubviews.h)：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;


@interface UIView (PrintSubviews)

- (void)printSubviewsWithIndentation:(int)indentation;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Objective-C的Category声明十分简单且重要。更重要的是我们的方法可以在任何UIView及其子类(UIScrollView, MKMapView, UITableView, UIButton 等等)中工作。现在看看category的实现文件，如下代码：  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;#import "UIView+printSubviews.h"


@implementation UIView (PrintSubviews)

- (void)printSubviewsWithIndentation:(int)indentation {

    // Get all the subviews of the current view
    NSArray *subviews = [self subviews];   

    // Loop through the whole subviews array. We are using the plain-old C-like for loop,
    // just for its simplicity and also to be provided with the iteration number
    for (int i = 0; i &amp;lt; [subviews count]; i++) {

        // Get the subview at current index
        UIView *currentSubview = [subviews objectAtIndex:i];   

        // We will create our description using this mutable string
        NSMutableString *currentViewDescription = [[NSMutableString alloc] init];

        // Indent the actual description to provide visual clue of  how deeply is the current view nested
        for (int j = 0; j &amp;lt;= indentation; j++) {
            [currentViewDescription appendString:@"   "];
        }

        // Construct the actual description string. Note that we are using just index of the current view
        // and name of its class, but it's up to you to print anything you are interested in
        // (for example the frame property using the NSStringFromCGRect(currentSubview.frame) )
        [currentViewDescription appendFormat:@"[%d]: class: '%@'", i, NSStringFromClass([currentSubview class])];

        // Log the description string to the console
        NSLog(@"%@", currentViewDescription);

        // Be good memory citizen
        [currentViewDescription release];

        // the 'recursiveness' nature of this method. Call it on the current subview, with greater indentation
        [currentSubview printSubviewsWithIndentation:indentation+1];
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我觉得不需要作太多的解释，因为十分的简单。现在我将给大家展示一个使用实例，以及该方法所产生的输出。我要在一个有多个annotations，其中一个annotation被选中并弹出callout view的MKMapView上使用改方法。&lt;/p&gt;

&lt;p&gt;首先你需要在你将要使用的类中引入这个category的头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;#import "UIView+printSubviews.h"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你希望检测的view上调用&lt;code&gt;-printSubviewsWithIndentation:&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;NSLog(@"*** Printing out all the subviews of MKMapView ***");  
[mapView printSubviewsWithIndentation:0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你可以看到如下的输出：
&lt;img src="http://localhost:2368/ru-he-jian-ce-ren-yi-viewde-subviewsde-guan-xi-shu/NO_Image" alt=""&gt;&lt;/p&gt;

&lt;p&gt;现在你可以看到mapView中所有藏在屏幕后面的view了，每一行输出前面的［］中的数字代表该行的view在树结构中的层次索引。&lt;/p&gt;

&lt;p&gt;你可以向下面这样获取到MKAnnotationContainerView&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;UIView *annotationContainerView = [[[[[[mapView subviews] objectAtIndex:0] subviews] objectAtIndex:0] subviews] objectAtIndex:1];  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这种获取方式是不安全的，因为它取决于视图的特定顺序。所以你在使用以上方法获取对应视图的时候必须对它做一次测试：
if [subviews count] &gt; 0，或者使用像下面这样使用 NSClassFromString()：  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;for (UIView *subview in subviews) {  
        if ([subview isKindOfClass:NSClassFromString(@"NameOfTheClass")]) {
            // We found the subview that we want
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我想提示大家，苹果不希望开发者这样做，因为一些UIKit类的子视图是私有的，因此他们将会在将来更改这些类。所以以上方法只能在你没有其他方式的情况下谨慎的使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如有错误请指正，谢谢&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title>如何添加 Quick actions</title><description>&lt;p&gt;原文地址：&lt;a href="http://iostuts.io/2015/10/08/how-to-add-quick-actions/"&gt;http://iostuts.io/2015/10/08/how-to-add-quick-actions/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇教程介绍了Quick actions是如何工作的，如何创建Quick actions以及如何执行actions。此外，我们创建一个简单的app包含两个静态的Quick actions和一个动态的Quick actions。&lt;/p&gt;

&lt;p&gt;我们首先开始静态Quick actions创建。他们都被定义在Info.plist文件的特定键－－UIApplicationShortcutItems中。每一个子项是一个字典且至少要包含以下键：
1. &lt;strong&gt;UIApplicationShortcutItemType&lt;/strong&gt; ：作为UIApplicationShortcutItem的一部分发送给你的应用。可以依据不同的shortcut类型用于执行你的actions。 &lt;br&gt;
2. &lt;strong&gt;UIApplicationShortcutItemTitle&lt;/strong&gt;：展示在你的quick action菜单中的action标题。如果标题一行无法显示并且你没有指定子标题那么它将显示两行。可以使用本地化(localised).&lt;/p&gt;

&lt;p&gt;一些可选键：
1. &lt;strong&gt;UIApplicationShortcutItemSubtitle&lt;/strong&gt;: 用户展示你的actions的子标题的字符串。它将显示在你的quick actions标题的下方。可以本地化。 &lt;br&gt;
2. &lt;strong&gt;UIApplicationShortcutItemIconType&lt;/strong&gt;：定义内置图标类型的字符串，可选类型列表可以查询&lt;a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationShortcutIcon_Class/index.html#//apple_ref/c/tdef/UIApplicationShortcutIconType"&gt;这里&lt;/a&gt;； &lt;br&gt;
3. UIApplicationShortcutItemIconFile：一个指定Assets Catalog或者Bundle中的字符串。图像尺寸和设计的详细信息可以在&lt;a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/index.html#//apple_ref/doc/uid/TP40006556-CH66-SW1"&gt;&lt;/a&gt;&lt;/p&gt;</description><link>http://localhost:2368/ru-he-tian-jia-quick-actions/</link><guid isPermaLink="false">89d00f44-1343-4641-93c4-491116a4802b</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 18 Feb 2016 06:02:13 GMT</pubDate><content:encoded>&lt;p&gt;原文地址：&lt;a href="http://iostuts.io/2015/10/08/how-to-add-quick-actions/"&gt;http://iostuts.io/2015/10/08/how-to-add-quick-actions/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇教程介绍了Quick actions是如何工作的，如何创建Quick actions以及如何执行actions。此外，我们创建一个简单的app包含两个静态的Quick actions和一个动态的Quick actions。&lt;/p&gt;

&lt;p&gt;我们首先开始静态Quick actions创建。他们都被定义在Info.plist文件的特定键－－UIApplicationShortcutItems中。每一个子项是一个字典且至少要包含以下键：
1. &lt;strong&gt;UIApplicationShortcutItemType&lt;/strong&gt; ：作为UIApplicationShortcutItem的一部分发送给你的应用。可以依据不同的shortcut类型用于执行你的actions。 &lt;br&gt;
2. &lt;strong&gt;UIApplicationShortcutItemTitle&lt;/strong&gt;：展示在你的quick action菜单中的action标题。如果标题一行无法显示并且你没有指定子标题那么它将显示两行。可以使用本地化(localised).&lt;/p&gt;

&lt;p&gt;一些可选键：
1. &lt;strong&gt;UIApplicationShortcutItemSubtitle&lt;/strong&gt;: 用户展示你的actions的子标题的字符串。它将显示在你的quick actions标题的下方。可以本地化。 &lt;br&gt;
2. &lt;strong&gt;UIApplicationShortcutItemIconType&lt;/strong&gt;：定义内置图标类型的字符串，可选类型列表可以查询&lt;a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationShortcutIcon_Class/index.html#//apple_ref/c/tdef/UIApplicationShortcutIconType"&gt;这里&lt;/a&gt;； &lt;br&gt;
3. UIApplicationShortcutItemIconFile：一个指定Assets Catalog或者Bundle中的字符串。图像尺寸和设计的详细信息可以在&lt;a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/index.html#//apple_ref/doc/uid/TP40006556-CH66-SW1"&gt;这里&lt;/a&gt;找到如果指定了此键，则系统会忽略&lt;strong&gt;UIApplicationShortcutItemIconType&lt;/strong&gt; &lt;br&gt;
4. &lt;strong&gt;UIApplicationShortcutItemUserInfo&lt;/strong&gt;：一个字典，包含你想要解析的其他信息。&lt;/p&gt;

&lt;p&gt;等不及向你展示它是如何工作的了。&lt;/p&gt;

&lt;p&gt;我们需要创建一个Single View应用(File -&gt; New -&gt; Project).&lt;/p&gt;

&lt;p&gt;接着，打开Info.Plist文件并拷贝黏贴以下内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;key&amp;gt;UIApplicationShortcutItems&amp;lt;/key&amp;gt;  
&amp;lt;array&amp;gt;  
  &amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;UIApplicationShortcutItemIconType&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;UIApplicationShortcutIconTypeSearch&amp;lt;/string&amp;gt;   
    &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;SHORTCUT_TITLE_SEARCH&amp;lt;/string
    &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key
    &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER).Search&amp;lt;/string&amp;gt;
  &amp;lt;/dict&amp;gt;
  &amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;SHORTCUT_TITLE_FAVORITES&amp;lt;/string
    &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key
    &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER).Favorites&amp;lt;/string&amp;gt;
  &amp;lt;/dict&amp;gt;
&amp;lt;/array&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你没有iPhone6s和6splus,那么可以用&lt;a href="https://github.com/DeskConnect/SBShortcutMenuSimulator"&gt;tweak&lt;/a&gt;在模拟器上测试。&lt;/p&gt;

&lt;p&gt;Build你的项目并试着3D touch你的app图标，它将向你展示一个菜单，十分的简单且很好，难道不是吗？ &lt;br&gt;
&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_1.png" alt="shortcuts_1.png"&gt;&lt;/p&gt;

&lt;p&gt;你可能已经注意到了两个问题：
1. 标题折行了。 &lt;br&gt;
2. 当你点击actions，它只是启动了app，并没有做任何的操作。&lt;/p&gt;

&lt;p&gt;让我们来完成余下的任务！&lt;/p&gt;

&lt;p&gt;我们的下一个挑战是如何执行这些actions。我们要时刻记得这有两种不同情况。
1. app处于关闭状态，用户通过quick action shorcut来打开应用。&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;将会被调用。参数launchingOptions字典中键名UIApplicationLaunchOptionsShortcutItemKey对应的value是UIApplicationShortcutItem对象。 &lt;br&gt;
2. app之前被打开过，此时处于挂起状态，用户通过shortcut继续使用。这种情况下应用将被唤醒，执行：&lt;code&gt;application:performActionForShortcutItem:completionHandler:&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;首先，我们创建一个私有方法，用来执行shortcut items。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;private func handleShortcutItem(shortcutItem: UIApplicationShortcutItem) {  
  if let rootViewController = window?.rootViewController {
    rootViewController.dismissViewControllerAnimated(false, completion: nil)
    let alertController = UIAlertController(title: "", message: shortcutItem.localizedTitle, preferredStyle: .Alert)
    alertController.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
    rootViewController.presentViewController(alertController, animated: true, completion: nil)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们添加当app通过quick action返回前台的时候获取shortcut item的逻辑，黏贴以下代码到&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;中。请不要忘记检测你的iOS系统版本，如果你的应用支持iOS8，app将会crash。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;if let shortcutItem = launchOptions?[UIApplicationLaunchOptionsShortcutItemKey] as? UIApplicationShortcutItem {  
  handleShortcutItem(shortcutItem)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后是声明：&lt;code&gt;application:performActionForShortcutItem:completionHandler:&lt;/code&gt;,该方法执行quick action，前提是app没有退出。将以下代码黏贴到AppDelegate中。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: (Bool) -&amp;gt; Void) {  
  handleShortcutItem(shortcutItem)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新运行app并按压icon图标。你会发现当你使用quick action时，将会弹出alert并附带action 标题。&lt;/p&gt;

&lt;p&gt;在实际应用中，你应该是希望不同的shortcut item执行不同的actions。前面已经述说了，&lt;strong&gt;UIApplicationShortcutItemType是用来标记actions类型的&lt;/strong&gt;。让我们继续吧！&lt;/p&gt;

&lt;p&gt;将以下代码黏贴到AppDelegate的声明中：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;enum DGShortcutItemType: String {  
    case Search
    case Favorites

    init?(shortcutItem: UIApplicationShortcutItem) {
        guard let last = shortcutItem.type.componentsSeparatedByString(".").last else { return nil }
        self.init(rawValue: last)
    }

    var type: String {
        return NSBundle.mainBundle().bundleIdentifier! + ".\(self.rawValue)"
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们这里做的十分简单。每一个shortcut item包含一个类型，在示例中是：
* &lt;code&gt;$(PRODUCT_BUNDLE_IDENTIFIER).Favorites&lt;/code&gt;
* &lt;code&gt;$(PRODUCT_BUNDLE_IDENTIFIER).Search&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们创建一个enumeration 用来解析这些值，可以使用比较简洁的写法：.Search 或者.Favorites&lt;/p&gt;

&lt;p&gt;现在用以下代码替换我们刚刚声明的handleShortcutItem方法&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;private func handleShortcutItem(shortcutItem: UIApplicationShortcutItem) {  
        if let rootViewController = window?.rootViewController, let shortcutItemType = DGShortcutItemType(shortcutItem: shortcutItem) {
            rootViewController.dismissViewControllerAnimated(false, completion: nil)
            let alertController = UIAlertController(title: "", message: "", preferredStyle: .Alert)

            switch shortcutItemType {
            case .Search:
                alertController.message = "It's time to search"
                break
            case .Favorites:
                alertController.message = "Show me my favorites"
                break
            }

            alertController.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
            rootViewController.presentViewController(alertController, animated: true, completion: nil)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我门已经做了以下事情：
1.  我么在if控制语句内添加了&lt;code&gt;let shortcutItemType = DGShortcutItemType(shortcutItem: shortcutItem)&lt;/code&gt; 来确保这些值不是空的。如果我们添加一个新的shortcut则它可能为空，但是不会向enum添加新值。 &lt;br&gt;
2.  添加转换语句， 使每一个shortcut item类型能有不同的action&lt;/p&gt;

&lt;p&gt;运行项目并测试。现在每一个shortcut应该可以展示不同的alert了。&lt;/p&gt;

&lt;p&gt;Hm. 但是有一个地方肯定是错误的，我不希望是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_3.png" alt="shortcuts_3.png"&gt;&lt;/p&gt;

&lt;p&gt;这些shortcut 没有对应的图片，看起来不如Search shortcut那么美观。我想改进它。&lt;/p&gt;

&lt;p&gt;下载这些文件（&lt;a href="https://drive.google.com/file/d/0B16pTxwnU1H4VnZzbDF0Y19aRkE/view?usp=sharing"&gt;this file&lt;/a&gt;），并提取其中的图片放到Images.xcassets.&lt;/p&gt;

&lt;p&gt;打开Info.plist源码，并在Favorites Item 中添加如下两行。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;key&amp;gt;UIApplicationShortcutItemIconFile&amp;lt;/key&amp;gt;  
&amp;lt;string&amp;gt;ShortcutIconFavorites&amp;lt;/string&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有UIApplicationShortcutItems项应该是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-HTML"&gt; &amp;lt;key&amp;gt;UIApplicationShortcutItems&amp;lt;/key&amp;gt;
    &amp;lt;array&amp;gt;
        &amp;lt;dict&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemIconType&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;UIApplicationShortcutIconTypeSearch&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;SHORTCUT_TITLE_SEARCH&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER).Search&amp;lt;/string&amp;gt;
        &amp;lt;/dict&amp;gt;
        &amp;lt;dict&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;SHORTCUT_TITLE_FAVORITES&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER).Favorites&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemIconFile&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;ShortcutIconFavorites&amp;lt;/string&amp;gt;
        &amp;lt;/dict&amp;gt;
    &amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行项目，现在当你3D touch 你的app icon时，你可以看到这样：
&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_4-1.png" alt="shortcuts_4-1.png"&gt;&lt;/p&gt;

&lt;p&gt;现在它看起来要好的多，我们已经学习了在quick action shortcuts中如何使用自定义assets。&lt;/p&gt;

&lt;p&gt;现在让我们来试着做一个动态的shortcut，从iOS9开始，UIApplication类有一个public变量&lt;code&gt;public var shortcutItems: [UIApplicationShortcutItem]?&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注册一个shortcuts 在home屏展示， 或者检索已经注册的shortcuts.&lt;/p&gt;

&lt;p&gt;这正是我们要使用的。我们将创建一个接口来允许我们输入数据并更新/删除当前的shortcut。&lt;/p&gt;

&lt;p&gt;打开viewcontroller.swift文件，并替换所有代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;import UIKit

extension UIApplicationShortcutIconType {  
    var toString: String {
        switch self {
        case .Compose: return "Compose"
        case .Play: return "Play"
        case .Pause: return "Pause"
        case .Add: return "Add"
        case .Location: return "Location"
        case .Search: return "Search"
        case .Share: return "Share"
        }
    }

    init?(string: String) {
        switch string {
        case "Compose": self.init(rawValue: UIApplicationShortcutIconType.Compose.rawValue)
        case "Play": self.init(rawValue: UIApplicationShortcutIconType.Play.rawValue)
        case "Pause": self.init(rawValue: UIApplicationShortcutIconType.Pause.rawValue)
        case "Add": self.init(rawValue: UIApplicationShortcutIconType.Add.rawValue)
        case "Location": self.init(rawValue: UIApplicationShortcutIconType.Location.rawValue)
        case "Search": self.init(rawValue: UIApplicationShortcutIconType.Search.rawValue)
        case "Share": self.init(rawValue: UIApplicationShortcutIconType.Share.rawValue)
        default: return nil
        }
    }

    static var allTypesToStrings: [String] {
        return [UIApplicationShortcutIconType.Compose.toString, UIApplicationShortcutIconType.Play.toString, UIApplicationShortcutIconType.Pause.toString, UIApplicationShortcutIconType.Add.toString, UIApplicationShortcutIconType.Location.toString, UIApplicationShortcutIconType.Search.toString, UIApplicationShortcutIconType.Share.toString]
    }
}

class ViewController: UIViewController {

    // MARK: -
    // MARK: Vars

    private let titleTextField = UITextField()
    private let subtitleTextField = UITextField()
    private var iconTypeSegmentedControl = UISegmentedControl(items: UIApplicationShortcutIconType.allTypesToStrings)
    private let updateButton = UIButton(type: .System)

    // MARK: -

    override func loadView() {
        super.loadView()
        titleTextField.placeholder = "Title"
        titleTextField.delegate = self
        view.addSubview(titleTextField)

        subtitleTextField.placeholder = "Subtitle"
        subtitleTextField.delegate = self
        view.addSubview(subtitleTextField);

        updateButton.setTitle("Update shortcut", forState: .Normal)
        updateButton.addTarget(self, action: Selector("updateDynamicAction"), forControlEvents: .TouchUpInside)
        view.addSubview(updateButton)

        iconTypeSegmentedControl.selectedSegmentIndex = 0
        view.addSubview(iconTypeSegmentedControl)

        view.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "viewTapped"))
    }

    // MARK: -
    // MARK: Methods

    func viewTapped() {
        view.endEditing(true)
    }

    func updateDynamicAction() {
        guard let title = titleTextField.text else {
            UIApplication.sharedApplication().shortcutItems = nil
            return
        }

        let type = NSBundle.mainBundle().bundleIdentifier! + ".Dynamic"
        let shortcutIconType = UIApplicationShortcutIconType(string: iconTypeSegmentedControl.titleForSegmentAtIndex(iconTypeSegmentedControl.selectedSegmentIndex)!)!
        let icon = UIApplicationShortcutIcon(type: shortcutIconType)

        let dynamicShortcut = UIApplicationShortcutItem(type: type, localizedTitle: title, localizedSubtitle: subtitleTextField.text, icon: icon, userInfo: nil)
        UIApplication.sharedApplication().shortcutItems = [dynamicShortcut]
    }

    // MARK: -
    // MARK: Layout

    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews()

        let width = view.bounds.width

        let horizontalMargin: CGFloat = 20.0
        let elementHeight: CGFloat = 40.0
        let verticalSpacing: CGFloat = 20.0

        titleTextField.frame = CGRect(x: horizontalMargin, y: 50.0, width: width - 2 * horizontalMargin, height: elementHeight)
        subtitleTextField.frame = CGRectOffset(titleTextField.frame, 0.0, elementHeight + verticalSpacing)
        iconTypeSegmentedControl.frame = CGRectOffset(subtitleTextField.frame, 0.0, elementHeight + verticalSpacing)
        updateButton.frame = CGRectOffset(iconTypeSegmentedControl.frame, 0.0, elementHeight + verticalSpacing)
    }

}

// MARK: -
// MARK: UITextField Delegate

extension ViewController: UITextFieldDelegate {

    func textFieldShouldReturn(textField: UITextField) -&amp;gt; Bool {
        if textField == titleTextField {
            subtitleTextField.becomeFirstResponder()
        } else if textField == subtitleTextField {
            subtitleTextField.resignFirstResponder()
        }

        return true
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些代码看起来很多，但是它十分基础并且不需要解释。&lt;/p&gt;

&lt;p&gt;运行项目，你会看到简单的界面：
&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_5.png" alt="shortcuts_5.png"&gt;&lt;/p&gt;

&lt;p&gt;点击：“Update shortcut” 添加一些数据。 试着3Dtouch你的app，你将看到如下情景：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_6-1.png" alt="shortcuts_6-1.png"&gt;&lt;/p&gt;

&lt;p&gt;有一个游戏，尝试改变值，按“更新的快捷方式”，它将改变。如果你离开了标题标签，并要求更新，那么该快捷方式将被删除。我们可以随时添加、删除、更改快捷方式。&lt;/p&gt;

&lt;p&gt;还有一件事情没有做了，就是当我们通过Dynamic shortcut来打开app的时候没有做任何事情。现在我们要添加alets，来展示如何做到这一点。&lt;/p&gt;

&lt;p&gt;以下时我们需要做的：
添加 case Dynamic 到 DGShortcutItemType enumeration 来支持这种类型。
在handleShortcutItem方法的switch语句中添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;case .Dynamic:  
    alertController.message = "Dynamic shortcut works!"
    break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在updateDynamicAction方法改变：
NSBundle.mainBundle().bundleIdentifier! + ".Dynamic" 修改为DGShortcutItemType.Dynamic.type&lt;/p&gt;

&lt;p&gt;运行项目并测试3D touch。 当你打开app， 它将展示每一个shortcuts指定的消息。&lt;/p&gt;

&lt;p&gt;我想我们已经完成了Quick Actions 主要逻辑。本教程源码在这里（&lt;a href="https://github.com/gontovnik/DGQuickActionsTutorial"&gt;here&lt;/a&gt;）可以下载。&lt;/p&gt;

&lt;p&gt;希望大家喜欢，并留下你们的观点和建议。再见！&lt;/p&gt;</content:encoded></item><item><title>UIPresentationController</title><description>&lt;p&gt;&lt;strong&gt;UIPresentationController&lt;/strong&gt;是在iOS8.0后出现，用来提供高级视图切换功能, 使管理present ViewController的过程变得简单。&lt;/p&gt;

&lt;h4 id=""&gt;&lt;strong&gt;重要属性及方法&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// presentation(演示)起点的ViewController(只读属性)
   public var presentingViewController: UIViewController { get }

// 要展示的ViewController(只读属性)
   public var presentedViewController: UIViewController { get }

// 演示风格
   public var presentationStyle: UIModalPresentationStyle { get }

// presented和presenting ViewController的祖先视图。
   public var containerView: UIView? { get }

/* presentation过程中的动画视图，必须是presentedViewController.view的祖先视图，或者是
  presentedViewController.view本身.(默认值：presentedViewController.view本身)*/
   public func presentedView() -&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/uipresentationcontroller/</link><guid isPermaLink="false">c6f29087-b69f-4708-8afe-0c4a576263ef</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 18 Feb 2016 05:20:52 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;UIPresentationController&lt;/strong&gt;是在iOS8.0后出现，用来提供高级视图切换功能, 使管理present ViewController的过程变得简单。&lt;/p&gt;

&lt;h4 id=""&gt;&lt;strong&gt;重要属性及方法&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// presentation(演示)起点的ViewController(只读属性)
   public var presentingViewController: UIViewController { get }

// 要展示的ViewController(只读属性)
   public var presentedViewController: UIViewController { get }

// 演示风格
   public var presentationStyle: UIModalPresentationStyle { get }

// presented和presenting ViewController的祖先视图。
   public var containerView: UIView? { get }

/* presentation过程中的动画视图，必须是presentedViewController.view的祖先视图，或者是
  presentedViewController.view本身.(默认值：presentedViewController.view本身)*/
   public func presentedView() -&amp;gt; UIView?

// 展示动画开始时调用
   public func presentationTransitionWillBegin()
// 展示动画结束后调用
   public func presentationTransitionDidEnd(completed: Bool)
// 消失动画开始时调用
   public func dismissalTransitionWillBegin()
// 消失动画结束时调用
   public func dismissalTransitionDidEnd(completed: Bool)
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>CGRectInset 和 CGRectOffset</title><description>&lt;h3 id="cgrectinset"&gt;CGRectInset&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; func CGRectInset(_ rect: CGRect, _ dx: CGFloat, _ dy: CGFloat) -&amp;gt; CGRect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回一个矩形，这个矩形以原矩形的中心点为中心，比原矩形大或者小。&lt;/p&gt;

&lt;p&gt;参数：&lt;br&gt;
rect:原矩形. &lt;br&gt;
dx:x坐标值用来调整原矩形。创建一个inset矩形，指定正值则比原矩形宽，指定负值则比原矩形窄. &lt;br&gt;
dy:y坐标值用来调整原矩形。创建一个inset矩形，指定正值则比原矩形高，指定负值则比原矩形短.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)testCGRectInset  
{  
    UIView *view1=[[UIView alloc]initWithFrame:CGRectMake(120, 120, 200, 200)];  
    [view1 setBackgroundColor:[UIColor grayColor]];//view1 设置为灰色  
    [self.view addSubview:&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/cgrectinset-he-cgrectoffset/</link><guid isPermaLink="false">efaa1ad3-946c-4240-8645-0318b6ec2d00</guid><dc:creator>ioneway</dc:creator><pubDate>Wed, 17 Feb 2016 08:32:50 GMT</pubDate><content:encoded>&lt;h3 id="cgrectinset"&gt;CGRectInset&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; func CGRectInset(_ rect: CGRect, _ dx: CGFloat, _ dy: CGFloat) -&amp;gt; CGRect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回一个矩形，这个矩形以原矩形的中心点为中心，比原矩形大或者小。&lt;/p&gt;

&lt;p&gt;参数：&lt;br&gt;
rect:原矩形. &lt;br&gt;
dx:x坐标值用来调整原矩形。创建一个inset矩形，指定正值则比原矩形宽，指定负值则比原矩形窄. &lt;br&gt;
dy:y坐标值用来调整原矩形。创建一个inset矩形，指定正值则比原矩形高，指定负值则比原矩形短.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)testCGRectInset  
{  
    UIView *view1=[[UIView alloc]initWithFrame:CGRectMake(120, 120, 200, 200)];  
    [view1 setBackgroundColor:[UIColor grayColor]];//view1 设置为灰色  
    [self.view addSubview:view1];  

    //根据view1的大小变换后创建view2;  
    CGRect view2Rect=CGRectInset(view1.frame, 20, 20);  
    UIView *view2=[[UIView alloc]initWithFrame:view2Rect];  
    [view2 setBackgroundColor:[UIColor blueColor]];//view2 设置为蓝色  
    [self.view addSubview:view2];  


}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码：产生的效果如图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/20150731115650388.png" alt="CGRectInset"&gt;&lt;/p&gt;

&lt;h3 id="cgrectoffset"&gt;CGRectOffset&lt;/h3&gt;

&lt;p&gt;返回一个经过平移后的矩形。(与原矩形大小一致)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func CGRectOffset(_ rect: CGRect, _ dx: CGFloat, _ dy: CGFloat) -&amp;gt; CGRect  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数：&lt;br&gt;
rect: 原矩形 &lt;br&gt;
dx: 平移的x坐标 &lt;br&gt;
dy: 平移的y坐标&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)testCGRectOffset  
{  
    UIView *view1=[[UIView alloc]initWithFrame:CGRectMake(120, 120, 200, 200)];  
    [view1 setBackgroundColor:[UIColor grayColor]];//view1 设置为灰色  
    [self.view addSubview:view1];  

    //根据view1的大小变换后创建view2;  
    CGRect view2Rect=CGRectOffset(view1.frame, 20, 20);  
    UIView *view2=[[UIView alloc]initWithFrame:view2Rect];  
    [view2 setBackgroundColor:[UIColor blueColor]];//view2 设置为蓝色  
    [self.view addSubview:view2];    
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
以上代码运行效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/20150731120023106.png" alt="CGRectOffset"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; CGRectInset主要是得到一个缩放了的矩形，而CGRectOffset是得到一个平移了的矩形。&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title>Hit-Testing in iOS</title><description>&lt;p&gt;&lt;code&gt;Hit-testing&lt;/code&gt;翻译为中文是"命中测试"，是确定touch-point是否在一个View内的过程,最终命中的View被称为&lt;code&gt;hit-test view&lt;/code&gt;。iOS使用hit-testing来确定那一个UIView是用户手指下最靠前的且能够接收touch事件的view。hit-testing通过&lt;code&gt;反向前序深度优先&lt;/code&gt;算法来便利视图的层次结构，从而实现上述功能。&lt;/p&gt;

&lt;p&gt;在解释hit-testing 如何工作前，我们先要了解下hit-testing是在什么时候执行的。以下图分解了一个手指从触摸屏幕到离开屏幕的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-touch-event-flow.png" alt="hit-test-touch-event-flow"&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，每次手指触碰屏幕都会触发hit-testing, 并且hit-testing在各个视图和gesture recognizer接收UIEvent 事件之前触发。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;不清楚是什么原因，hit-testing会连续执行多次。并且，hit-test view 的hit-testing也会执行多次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;hit-testing完成后，最前方且能够接收事件的view就会被确定为hit-test view。hit-test view与各个阶段(begin,move,end,cancel)的触摸事件序列的UITouch对象相关联。hit-test view确定后，开始接收touch事件序列。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;需要了解的是，手指被移动到了hit-test view外，而移动到了另一个view内时，hit-test视图依旧会&lt;code&gt;接收整个&lt;/code&gt;touch事件的序列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description><link>http://localhost:2368/hit-testing-in-ios/</link><guid isPermaLink="false">5dd1d295-69d5-4499-916a-32480d5dcb11</guid><dc:creator>ioneway</dc:creator><pubDate>Tue, 16 Feb 2016 06:29:52 GMT</pubDate><content:encoded>&lt;p&gt;&lt;code&gt;Hit-testing&lt;/code&gt;翻译为中文是"命中测试"，是确定touch-point是否在一个View内的过程,最终命中的View被称为&lt;code&gt;hit-test view&lt;/code&gt;。iOS使用hit-testing来确定那一个UIView是用户手指下最靠前的且能够接收touch事件的view。hit-testing通过&lt;code&gt;反向前序深度优先&lt;/code&gt;算法来便利视图的层次结构，从而实现上述功能。&lt;/p&gt;

&lt;p&gt;在解释hit-testing 如何工作前，我们先要了解下hit-testing是在什么时候执行的。以下图分解了一个手指从触摸屏幕到离开屏幕的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-touch-event-flow.png" alt="hit-test-touch-event-flow"&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，每次手指触碰屏幕都会触发hit-testing, 并且hit-testing在各个视图和gesture recognizer接收UIEvent 事件之前触发。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;不清楚是什么原因，hit-testing会连续执行多次。并且，hit-test view 的hit-testing也会执行多次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;hit-testing完成后，最前方且能够接收事件的view就会被确定为hit-test view。hit-test view与各个阶段(begin,move,end,cancel)的触摸事件序列的UITouch对象相关联。hit-test view确定后，开始接收touch事件序列。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;需要了解的是，手指被移动到了hit-test view外，而移动到了另一个view内时，hit-test视图依旧会&lt;code&gt;接收整个&lt;/code&gt;touch事件的序列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;“The touch object is associated with its hit-test view for its lifetime, even if the touch later moves outside the view.”&lt;br&gt;
  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
  &lt;a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4"&gt;Event Handling Guide for iOS, iOS Developer Library&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如前所述，命中测试采用反向预定深度优先遍历（先访问根结点，然后遍历其子树由高到低的指标）。这种遍历可以减少遍历迭代次数，并在搜索到第一个包含touch-point的最深的子视图中停止搜索过程。这可能是因为一个视图总是在它的父视图之前渲染，而兄弟视图总是比在subviews具有较低索引的兄弟视图先渲染。这样，多个重叠的视图都包含一个touch-point时，在右子树的最深的视图是第一个被渲染的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Visually, the content of a subview obscures all or part of the content of its parent view. Each superview stores its subviews in an ordered array and the order in that array also affects the visibility of each subview. If two sibling subviews overlap each other, the one that was added last (or was moved to the end of the subview array) appears on top of the other.”&lt;br&gt;
  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html#//apple_ref/doc/uid/TP40009503-CH2-SW24"&gt;View Programming Guide for iOS, iOS Developer Library&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下图显示了一个视图层次树及其匹配的用户界面。从左到右树枝序列影响着subviews的数组顺序。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-view-hierarchy.png" alt="hit-test-view-hierarchy"&gt;&lt;/p&gt;

&lt;p&gt;图中可以看到，“VIewA”和“ViewB”和它们的子视图，“ViewA.2”和“View B.1”有重叠。但是“ViewB”在subViews中的索引值高于“ViewA”，“ViewB”和它的子视图会展现在“View A”和它的子视图之上。 因此，用户手指触摸 “View.b.1”与”View.A.2”重叠区域时，hit-testing返回“View.B.1”。&lt;/p&gt;

&lt;p&gt;通过应用深度优先反向前序遍历算法，各个视图的遍历路径如图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-depth-first-traversal.png" alt="hit-test-depth-first-traversal"&gt;&lt;/p&gt;

&lt;p&gt;遍历算法先发送hitTest:withEvent: 到UIWindow，UIWindow是视图层次结构的根视图。此方法返回的值是包含了触摸点的最靠前面的视图。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;下面的流程图说明了命中测试逻辑。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-flowchart.png" alt="hit-test-flowchart"&gt;&lt;/p&gt;

&lt;p&gt;以下代码是&lt;code&gt;hitTest:withEvent:&lt;/code&gt;可能的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    if ([self pointInside:point withEvent:event]) {
        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            if (hitTestView) {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法首先检查视图是否允许接收touch事件。如果一个View允许接收touch事件，则必须满足以下所有条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;self.hidden == NO&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;self. self.userInteractionEnabled = YES&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.alpha &amp;gt; 0.1&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointInside:withEvent: == YES&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当视图View允许接收touch事件时，该方法就会反向枚举它的子视图，然后逐个发送&lt;code&gt;hitTest:withEvent:&lt;/code&gt;消息，直到有一个子视图返回了nil。第一个返回非nil值的子视图就是这些子视图中最靠前且在touch-point下的视图。如果所有视图都返回nil或者该视图没有子视图则函数返回self.&lt;/p&gt;

&lt;p&gt;如果视图View不允许接收touch事件，该方法返回nil,而不需要在反向枚举。因此，hit-testing并不需要访问视图层次树上的所有视图。&lt;/p&gt;

&lt;h4 id="hittestwithevent"&gt;hitTest:withEvent:运用场景&lt;/h4&gt;

&lt;p&gt;hitTest:withEvent:可以被覆盖，当所有触摸事件阶段的所有阶段的触摸事件想要被一个视图处理重定向到另外一个视图。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;*注意: *&lt;/em&gt;因为hit-test仅仅在触摸事件顺序的第一次触摸事件（UITouchPhaseBegan phase(阶段)的触摸事件）发送给他的接收者之前，覆盖hitTest:withEvent:来重定向事件将会重定向所有phase的触摸事件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1.增加视图区域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;覆盖&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法的一个用途就是，当一个视图的触摸区域应该大于他的边界的时候。例如下面的插图显示了一个大小为20*20的视图。这个大小对于处理附近的触摸来说太小了。因此，他的触摸区域可以通过覆盖&lt;code&gt;hitTest:withEvent:&lt;/code&gt;在每个方向增加10。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-increase-touch-area.png" alt="hit-test-increase-touch-area"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    CGRect touchRect = CGRectInset(self.bounds, -10, -10);
    if (CGRectContainsPoint(touchRect, point)) {
        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            if (hitTestView) {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;为了能够正确的调用&lt;code&gt;hit-test&lt;/code&gt;，父视图的边界应该包含子视图希望触摸的区域，或者他的&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法也应该被覆盖来包含期望的触摸区域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2.传递触摸事件给下面的视图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有的时候对于一个视图忽略触摸事件并传递给下面的视图是很重要的。例如，假设一个透明的视图覆盖在应用内所有视图的最上面。覆盖层有子视图应该相应触摸事件的一些控件和按钮。但是触摸覆盖层的其他区域应该传递给覆盖层下面的视图。为了完成这个行为，覆盖层需要覆盖hitTest:withEvent:方法来返回包含触摸点的子视图中的一个，然后其他情况返回nil，包括覆盖层包含触摸点的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *hitTestView = [super hitTest:point withEvent:event];
    if (hitTestView == self) {
        hitTestView = nil;
    }
    return hitTestView;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.传递触摸事件给子视图&lt;/strong&gt;
一个不同的使用场景可能需要父视图重定向所有的触摸事件给他唯一的子视图。这个行为是有必要的当子视图部分占据他的父视图，但是子视图应该响应所有的触摸事件包括发生在父视图上的。例如，假设一个由一个父视图和一个&lt;code&gt;pagingEnabled&lt;/code&gt;设置为YES和&lt;code&gt;clipsToBounds&lt;/code&gt;设置为NO（为了实现传动带的效果）的&lt;code&gt;UIScrollView&lt;/code&gt;组成的图片浏览器：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-pass-touches-to-subviews.png" alt="hit-test-pass-touches-to-subviews"&gt;&lt;/p&gt;

&lt;p&gt;为了使&lt;code&gt;UIScrollView&lt;/code&gt;响应不发生在自己边界内但是在父视图的边界内的触摸事件，父视图的&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法应该像下面这样重写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *hitTestView = [super hitTest:point withEvent:event];
    if (hitTestView) {
        hitTestView = self.scrollView;
    }
    return hitTestView;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;如有问题请指正, 谢谢。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外一篇是一位大神的翻译，翻译了一半的时候才发现的，索性后半部分就直接粘贴了。&lt;br&gt;
大神翻译：&lt;a href="http://joywii.github.io/blog/2015/03/17/ioszhong-de-hit-testing/"&gt;http://joywii.github.io/blog/2015/03/17/ioszhong-de-hit-testing/&lt;/a&gt;&lt;br&gt;
原文地址：&lt;a href="http://smnh.me/hit-testing-in-ios/"&gt;http://smnh.me/hit-testing-in-ios/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>GitHubPages＋Ghost搭建博客</title><description>&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/headImg-3.jpg" alt="The Ghost Logo"&gt;&lt;/p&gt;

&lt;p&gt;对IT技术的学习也有不短的时间了。经常观看大神们的博客，对于他们博客不仅仅内容精彩，而且主题也很大气高端，所以也希望自己能有一个这样的博客。&lt;/p&gt;

&lt;p&gt;首先就是要选择博客平台，经过一番对比，最终选&lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;，因为其免费且专业，并且还有以下优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简易的配置，轻量级别系统，不需要数据库&lt;/li&gt;
&lt;li&gt;支持标记语言，如Markdown&lt;/li&gt;
&lt;li&gt;使用GitHub托管服务，免费300MB空间&lt;/li&gt;
&lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;li&gt;支持CDN，提升访问速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然GitHub Pages也有一些缺陷：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt; 模板系统，属于静态页面&lt;/li&gt;
&lt;li&gt;基于Git操作，需要有一定的动手能力&lt;/li&gt;
&lt;li&gt;动态性不好，没有评论系统，不过可以自己配置&lt;a href="https://disqus.com"&gt;Disqus&lt;/a&gt; 扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于GitHub Pages对Jekyll无缝支持。可是我在Jekyll主题市场里找了许久，没能找到我想要的那种看上去简洁，高端，并且适合程序员写技术博客的主题。于是就去借鉴大神们的选择，发现OneV‘cat的博客主题:&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;正是我所想要的那种。&lt;/p&gt;

&lt;p&gt;OneVcat中使用的博客程序是&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;是一种轻量级的动态博客，&lt;/p&gt;</description><link>http://localhost:2368/githubpages-ghostda-jian-bo-ke/</link><guid isPermaLink="false">cc9b5426-38d8-41e8-8022-8b289e963f66</guid><dc:creator>ioneway</dc:creator><pubDate>Sat, 30 Jan 2016 09:28:09 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/headImg-3.jpg" alt="The Ghost Logo"&gt;&lt;/p&gt;

&lt;p&gt;对IT技术的学习也有不短的时间了。经常观看大神们的博客，对于他们博客不仅仅内容精彩，而且主题也很大气高端，所以也希望自己能有一个这样的博客。&lt;/p&gt;

&lt;p&gt;首先就是要选择博客平台，经过一番对比，最终选&lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;，因为其免费且专业，并且还有以下优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简易的配置，轻量级别系统，不需要数据库&lt;/li&gt;
&lt;li&gt;支持标记语言，如Markdown&lt;/li&gt;
&lt;li&gt;使用GitHub托管服务，免费300MB空间&lt;/li&gt;
&lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;li&gt;支持CDN，提升访问速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然GitHub Pages也有一些缺陷：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt; 模板系统，属于静态页面&lt;/li&gt;
&lt;li&gt;基于Git操作，需要有一定的动手能力&lt;/li&gt;
&lt;li&gt;动态性不好，没有评论系统，不过可以自己配置&lt;a href="https://disqus.com"&gt;Disqus&lt;/a&gt; 扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于GitHub Pages对Jekyll无缝支持。可是我在Jekyll主题市场里找了许久，没能找到我想要的那种看上去简洁，高端，并且适合程序员写技术博客的主题。于是就去借鉴大神们的选择，发现OneV‘cat的博客主题:&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;正是我所想要的那种。&lt;/p&gt;

&lt;p&gt;OneVcat中使用的博客程序是&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;是一种轻量级的动态博客，有一个管理后台，可以直接写作和管理博客。本质上和WordPress是相通的，只是 Ghost 搭建在 Node.js 环境上，轻量，快速，简洁。&lt;/p&gt;

&lt;p&gt;所以我最终选择了&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，因为其高颜值和强大的后台管理,另外还有一个原因就是它还有&lt;a href="http://www.ghostchina.com"&gt;中文版Ghost&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 技术栈简要解析
把 &lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 的结构厘清，其实蛮简单，特别是使用官方已经编译好的 &lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 压缩包解压后进行二次开发的话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ghost 的页面使用的是 &lt;code&gt;Handlebars.js&lt;/code&gt; 前端模板引擎，页面总数在 10 个左右。页面采用&lt;code&gt;引入/调用&lt;/code&gt;方式，就是把常规的 HTML 结构，譬如 &lt;code&gt;meta&lt;/code&gt; 头信息、&lt;code&gt;header&lt;/code&gt;、&lt;code&gt;footer&lt;/code&gt; 等常用且可以复用的 HTML 页面结构，给独立成一个个模板文件，而在其他诸如&lt;code&gt;单篇博文页、博主个人主页&lt;/code&gt;等页面模板文件内，引用上面的独立模板文件。譬如在单篇博文页内引入 meta 头信息模板文件，就可以达到一处编写,处处调用的类似&lt;code&gt;变量调用/引入&lt;/code&gt;的概念。&lt;strong&gt;前端模板引擎的出现，给前端开发人员缩短开发周期起到了不可或缺的作用&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于GitHub Pages只支持静态博客，而Ghost却是动态的。所谓动态博客，需要服务器来支持数据输出。而静态页面，就是诸如&lt;code&gt;HTML&lt;/code&gt;,&lt;code&gt;XML&lt;/code&gt;等标记语言写好结构，用&lt;code&gt;css&lt;/code&gt;描述好表现样式，用&lt;code&gt;JavaScript&lt;/code&gt;写好了交互逻辑的，理论上不再接受后端服务器数据输出而动态修改的页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;简而言之，静态页面是死的，动态页面是活的。&lt;/em&gt;&lt;/strong&gt;对于Github Pages这样仅仅支持静态网站/页面的托管服务而言，怎么搞定Ghost的托管呢？&lt;/p&gt;

&lt;h3 id="buster"&gt;&lt;strong&gt;开源项目&lt;code&gt;Buster&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Buster是&lt;code&gt;Python&lt;/code&gt;语言写的一个&lt;strong&gt;文件路径遍历器&lt;/strong&gt;。通过调用&lt;code&gt;Wget&lt;/code&gt;把Ghost中用到的图片，字体，CSS，javaScript等静态资源统一复制到一个新的文件夹(同时此文件夹可以作为Github Pages的仓库)，然后相应地修改HTML文件内引用的静态文件的路径，使之最终生效。Buster由Misiur提供：&lt;a href="https://github.com/Misiur/buster"&gt;https://github.com/Misiur/buster&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=""&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;1, &lt;a href="https://nodejs.org/en/download/releases"&gt;Node.js&lt;/a&gt;：Ghost依赖Node.js。 建议安装v0.10.26版本。&lt;/p&gt;
  
  &lt;p&gt;2, &lt;a href="http://git-scm.com/download"&gt;Git&lt;/a&gt;: 用于克隆项目到本地，部署、提交项目到 Github。Mac OSX 自带。&lt;/p&gt;
  
  &lt;p&gt;3, &lt;a href="https://www.python.org/downloads/"&gt;Python&lt;/a&gt;：用于执行Buster工具，Mac OSX自带。&lt;/p&gt;
  
  &lt;p&gt;4, &lt;a href="https://github.com/pypa/pip"&gt;pip&lt;/a&gt;: Python包管理工具，用于安装Buster工具。&lt;/p&gt;
  
  &lt;p&gt;5, &lt;a href="https://github.com/Misiur/buster"&gt;Buster&lt;/a&gt;: 用于将Ghost动态页面转换为静态页面。&lt;/p&gt;
  
  &lt;p&gt;6, &lt;a href="https://github.com/diancloud/Ghost"&gt;Ghost中文版&lt;/a&gt;：建议安装中文版，因为中文版已经包含了所有需要的插件。&lt;/p&gt;
  
  &lt;p&gt;7, &lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;：一款简洁高端大气的ghost博客主题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=""&gt;&lt;strong&gt;具体步骤&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1，搭建环境&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装node.js，建议v0.10.6版本&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;brew update  
brew install nvm //安装nvm  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在(~/.bashrc, ~/.profile, or ~/.zshrc)中添加如下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#For NVM
export NVM_DIR=~/.nvm  
source $(brew --prefix nvm)/nvm.sh  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用nvm安装node.js &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nvm install v0.10.6  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入用户Documents目录,并新建文件夹：GithubPages_ZH.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-Shell"&gt;cd ~/Documents &amp;amp;&amp;amp; mkdir GithubPages_ZH  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH目录，并下载&lt;a href="https://github.com/diancloud/Ghost"&gt;Ghost中文版&lt;/a&gt;，并将其命名为Ghost。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd GithubPages_ZH  
git clone https://github.com/diancloud/Ghost.git  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH/Ghost/content/themes/, 然后下载&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;主题.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd Ghost/content/themes/  
git clone https://github.com/onevcat/vno.git  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH/Ghost 启动Ghost服务&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;nvm use default 0.10.6  
npm start  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器打开:&lt;a href="http://localhost:2368/ghost"&gt;http://localhost:2368/ghost&lt;/a&gt;进入后台管理页面。注册一个管理员帐号，并记住帐号密码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置主题
点击左侧栏“全局设置”按钮，进入设置页面，下滑到最下方，主题：选择vno主题，并保存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装pip:Python包管理工具&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo easy_install pip  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装Buster: 执行以下命令&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;pip install git+https://github.com/Misiur/buster  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登陆Github 创建仓库，仓库名称&lt;code&gt;必须是&lt;/code&gt;：&lt;code&gt;[your－username].github.io&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终端执行以下命令：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd ~/GithubPages_ZH  
buster setup -gh-repo=\  
"https://github.com/&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git"
//这里会要求输入github帐号密码。
buster generate //产生静态文件，此时会在当前文件夹下产生static文件夹。  
buster deploy  //发布  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在static文件夹下添加文件：.gitignore文件，用于在提交github时忽略部分文件。在.gitignore中添加如下内容：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# vim ~tmp files
*.swp
*.un~

# ignore bourbon install so that it is the latest build
# for developers that need it
assets/scss/bourbon/*

# ignore the sass-cache/
.sass-cache/*
**/.sass-cache/*

### OSX ###
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear on external disk
.Spotlight-V100
.Trashes

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder  
Temporary Items  
.apdisk
config.codekit  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;你需要根据自己的实际情况对主题中各个按钮的点击链接以及图片进行设置，具体请参考链接：&lt;a href="https://github.com/onevcat/vno"&gt;https://github.com/onevcat/vno&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，Ghost博客搭建完成。之后每次跟新博客时：需要点击编辑窗口右上方的更新按钮，然后终端执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//在GithubPages_ZH下执行
//不需要再次执行Buster setup 命令
buster generate  
buster deploy  //发布  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="ghost"&gt;Ghost 相关资源推荐&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;各种 Ghost 主题：&lt;a href="http://www.allghostthemes.com"&gt;http://www.allghostthemes.com&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;官方主题市场：&lt;a href="http://marketplace.ghost.org"&gt;http://marketplace.ghost.org&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="ghost"&gt;&lt;strong&gt;Ghost高级设置&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;添加评论系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;ol&gt;
&lt;li&gt;注册&lt;a href="http://duoshuo.com"&gt;多说&lt;/a&gt;帐号,点击“安装”按钮并填写相关设置;  &lt;/li&gt;
&lt;li&gt;复制稳定版通用代码，黏贴在：&lt;code&gt;Ghost/content/themes/casper/post.hbs&lt;/code&gt;模板文件的 ｀｀&lt;code&gt;{{/post}}&lt;/code&gt; 标签前，并保存。 &lt;br&gt;
如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-22-43.png" alt="duoshuo_code"&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意&lt;/code&gt;将其中中文字符分别替换为：&lt;code&gt;{{id}}&lt;/code&gt;， &lt;code&gt;{{title}}&lt;/code&gt;，&lt;code&gt;ioneway.github.io{{url}}&lt;/code&gt;. 其中&lt;code&gt;ioneway.github.io&lt;/code&gt;替换为你的域名。
  
  最终粘贴的代码如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 多说评论框 start --&amp;gt;  
    &amp;lt;div class="ds-thread" data-thread-key="{{id}}" data-title="{{title}}" data-url="ioneway.github.io{{url}}"&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!-- 多说评论框 end --&amp;gt;  
&amp;lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&amp;gt;  
&amp;lt;script type="text/javascript"&amp;gt;  
var duoshuoQuery = {short_name:"abcbytr"};  
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    &amp;lt;/script&amp;gt;
&amp;lt;!-- 多说公共JS代码 end --&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登陆多说，进入设置页面，基本设置。正确填写以下两项：首页网址：&lt;a href="http://ioneway.github.io"&gt;http://ioneway.github.io&lt;/a&gt;
，首选域名：选择最后一项：“将网址显示为ioneway.github.io”。保存。&lt;/p&gt;

&lt;p&gt;如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-41-14.png" alt="duoshuo_setting"&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2，添加 CNZZ 统计&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1， 注册&lt;a href="http://www.cnzz.com"&gt;CNZZ&lt;/a&gt; &lt;br&gt;
2， 登陆&lt;a href="http://www.cnzz.com"&gt;CNZZ&lt;/a&gt; &lt;code&gt;站点设置&lt;/code&gt;, &lt;code&gt;获取代码&lt;/code&gt; 选择其中一种，并复制代码 &lt;br&gt;
如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-54-11.png" alt="duoshuo_setting"&gt;&lt;/p&gt;

&lt;p&gt;3， 终端输入命令&lt;code&gt;npm start&lt;/code&gt;开启服务 &lt;br&gt;
4， 浏览器输入&lt;a href="http://localhost:2368/ghost"&gt;http://localhost:2368/ghost&lt;/a&gt;进入后台管理。 &lt;br&gt;
5. 点击左侧边栏：&lt;code&gt;插入代码&lt;/code&gt;，将复制的代码粘贴在&lt;code&gt;页脚&lt;/code&gt;框中，保存。&lt;/p&gt;

&lt;p&gt;至此，你的博客就有了基本完整的功能了，你可以登录多说和&lt;a href="http://www.cnzz.com"&gt;CNZZ&lt;/a&gt;管理你的站点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如有遗漏，欢迎指正。谢谢。&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title>欢迎使用 Ghost 博客系统</title><description>&lt;p&gt;Yeah，博客上线了！这篇文章的目的是向你介绍 Ghost 编辑器并帮你快速上手。通过 &lt;code&gt;&amp;lt;your blog URL&amp;gt;/ghost/&lt;/code&gt; 链接就可以登录系统后台管理你的博客内容了。当你进入后台，你就能看到左侧文章列表处列出的这篇文章，右侧就是这篇文章的预览效果。点击预览栏右上角的铅笔图标就能进入内容编辑页面。 &lt;/p&gt;

&lt;h2 id=""&gt;快速入门&lt;/h2&gt;

&lt;p&gt;Ghost 使用 Markdown 语法书写内容。简单来说，Markdown 就是一种简化的书写格式！&lt;/p&gt;

&lt;p&gt;用 Markdown 语法写作是很容易的。在编辑界面的左侧就是你写作的地方。在你认为需要的时候，可以使用以下这些语法来格式化你的内容。例如下面这个无序列表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Item number one&lt;/li&gt;
&lt;li&gt;Item number two
&lt;ul&gt;&lt;li&gt;A nested item&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A final item&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还可以是有序列表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Remember to buy some milk&lt;/li&gt;&lt;/ol&gt;</description><link>http://localhost:2368/welcome-to-ghost/</link><guid isPermaLink="false">9dddcac0-0676-4542-aa19-7d7902bd1962</guid><category>系统简介</category><dc:creator>ioneway</dc:creator><pubDate>Thu, 28 Jan 2016 16:36:59 GMT</pubDate><content:encoded>&lt;p&gt;Yeah，博客上线了！这篇文章的目的是向你介绍 Ghost 编辑器并帮你快速上手。通过 &lt;code&gt;&amp;lt;your blog URL&amp;gt;/ghost/&lt;/code&gt; 链接就可以登录系统后台管理你的博客内容了。当你进入后台，你就能看到左侧文章列表处列出的这篇文章，右侧就是这篇文章的预览效果。点击预览栏右上角的铅笔图标就能进入内容编辑页面。 &lt;/p&gt;

&lt;h2 id=""&gt;快速入门&lt;/h2&gt;

&lt;p&gt;Ghost 使用 Markdown 语法书写内容。简单来说，Markdown 就是一种简化的书写格式！&lt;/p&gt;

&lt;p&gt;用 Markdown 语法写作是很容易的。在编辑界面的左侧就是你写作的地方。在你认为需要的时候，可以使用以下这些语法来格式化你的内容。例如下面这个无序列表：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Item number one&lt;/li&gt;
&lt;li&gt;Item number two
&lt;ul&gt;&lt;li&gt;A nested item&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;A final item&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;还可以是有序列表：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Remember to buy some milk  &lt;/li&gt;
&lt;li&gt;Drink the milk  &lt;/li&gt;
&lt;li&gt;Tweet that I remembered to buy the milk, and drank it&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=""&gt;链接&lt;/h3&gt;

&lt;p&gt;如果要链接其它页面，可以直接把页面的 URL 粘贴过来，例如 &lt;a href="http://www.ghostchina.com"&gt;http://www.ghostchina.com&lt;/a&gt; - 会被自动识别为链接。但是，如果你想自定义链接文本，可以像这样： &lt;a href="http://www.ghostchina.com"&gt;Ghost 中文网&lt;/a&gt;。很简单吧！&lt;/p&gt;

&lt;h3 id=""&gt;图片&lt;/h3&gt;

&lt;p&gt;插入图片也没问题！前提是你事先知道图片的 URL，然后像下面这样：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://static.ghostchina.com/image/3/fe/34a9831916be9db1381ecb320491e.png" alt="The Ghost Logo"&gt;&lt;/p&gt;

&lt;p&gt;如果图片在本地的硬盘里怎么办？也很简单！像下面这样书写就能为图片预留一个位置，然后你可以继续写作，回头再通过拖拽的方式把图片上传到服务器上。&lt;/p&gt;

&lt;h3 id=""&gt;引用&lt;/h3&gt;

&lt;p&gt;有些时候我们需要引用别人说的话，可以这样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Wisdomous - it's definitely a word.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=""&gt;代码&lt;/h3&gt;

&lt;p&gt;或许你是个码农，需要贴一些代码到文章里，可以通过两个引号（Tab 键上面的那个键）加入行内代码 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;。如果需要加入大段的代码，可以在代码前加 4 个空格缩进，这就是 Markdown 的语法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.awesome-thing {
    display: block;
    width: 100%;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=""&gt;分割线&lt;/h3&gt;

&lt;p&gt;在任一新行输入 3 个或更多的短横线（减号）就是一条分隔线了。&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=""&gt;高级用法&lt;/h3&gt;

&lt;p&gt;Markdown 还有一个特别用法，就是在你需要的时候可以直接书写 HTML 代码。&lt;/p&gt;

&lt;p&gt;&lt;input type="text" placeholder="这是个输入框！"&gt;&lt;/p&gt;

&lt;p&gt;只要掌握了上面的这些介绍，你就已经入门了！继续写作吧！&lt;/p&gt;</content:encoded></item></channel></rss>