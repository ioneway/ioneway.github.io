<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>iOneWay Blog</title><description>QQ:373850874. 欢迎加入。</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Fri, 15 Sep 2017 15:21:13 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>UIScrollView常用属性</title><description>&lt;p&gt;1，设置内容区域大小  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.contentSize = CGSizeMake(500, 600);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2, 设置内容区域偏移量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.contentOffset = CGPointMake(300, 0);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3, 设置内容区域相对于frame在哪里显示  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.contentInset = UIEdgeInsetsMake(100, 100, 0, 0);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4， 关闭滑动的回弹效果  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.bounces = NO;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5, 设置点击状态栏，scrollView能否滑动最顶端  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.scrollsToTop = YES;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6, 设置scrollView是否可以整屏滑动(一次滑动整个scrollView的大小)  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.pagingEnabled = YES;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7, 设置最大缩放比例：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.maximumZoomScale = 4.0  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8, 设置最小缩放比例  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.minimumZoomScale&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/uiscrollviewhong-fa-ji-zhi/</link><guid isPermaLink="false">45483093-2077-49c8-a4c4-b408eb8c5676</guid><dc:creator>ioneway</dc:creator><pubDate>Sun, 10 Apr 2016 09:00:07 GMT</pubDate><content:encoded>&lt;p&gt;1，设置内容区域大小  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.contentSize = CGSizeMake(500, 600);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2, 设置内容区域偏移量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.contentOffset = CGPointMake(300, 0);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3, 设置内容区域相对于frame在哪里显示  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.contentInset = UIEdgeInsetsMake(100, 100, 0, 0);  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4， 关闭滑动的回弹效果  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.bounces = NO;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5, 设置点击状态栏，scrollView能否滑动最顶端  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.scrollsToTop = YES;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6, 设置scrollView是否可以整屏滑动(一次滑动整个scrollView的大小)  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.pagingEnabled = YES;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7, 设置最大缩放比例：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.maximumZoomScale = 4.0  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8, 设置最小缩放比例  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;scrollView.minimumZoomScale = 1.0;  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="uiscrollviewdelegate"&gt;UIScrollViewDelegate的触发机制&lt;/h4&gt;

&lt;p&gt;1, 只要ScrollView有滑动(不管是拖，拉，放大，缩小都导致)都会执行，且不止执行一次  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewDidScroll:(UIScrollView *)scrollView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2, 将要拖曳scrollView时触发，手指接触ScrollView并且将要滑动时触发。  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewBeginDragging:(UIScrollView *)scrollView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3, 结束拖曳时触发(手指停止拖曳并将要离开屏幕)  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewWillEndDragging:(UIScrollView *)scrollView withVelocity:(CGPoint)velocity targetContentOffset:(inout CGPoint *)targetContrentOffset 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4,结束拖曳时触发(手指已经离开屏幕)  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5, 当scrollView滑动将要减速时触发(将要停止)  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6, 当scrollView 结束减速时触发(停止滑动)  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewDidEndDecelerating:(UIScrollView *)scrollVIew
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7, 当设置scrollView,有一个动画效果时触发  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;8, 设置要缩放的scrollView上面的哪一个子视图，只能时子视图，不能时scrollview本身。  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(UIView *)viewForZoomingInScrollView:(UIScrollView *)scrollView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;9，当将要开始缩放时触发  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewWillBeginZooming:(UIScrollView *)scrollView withView:(UIView *)view
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10, 当结束缩放时触发  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewDidEndZooming:(UIScrollView *)scrollView withView:(UIView *)view atScale:(CGFloat)scale
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;11, 只有当scrollToTop＝YES时，该方法才回触发，进一步询问点击状态栏是否有效  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(BOOL)scrollViewShouldScrollToTop:(UIScrollView *)scrollView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;12, 当点击状态栏并且scrollView滑动到顶端时触发  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)scrollViewDidScrollToTop:(UIScrollView *)scrollView
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>Swift 关键字：@noescape</title><description>&lt;p&gt;Swift1.2发布时就已经有这个关键字了。正确使用它可以使我们避免许多不希望的保留环。&lt;/p&gt;

&lt;p&gt;@noescape主要用在对函数中的closure参数修饰。&lt;/p&gt;

&lt;p&gt;使用@noescape修饰closure后，clousure的生命周期要比函数的调用周期短，也就是说clousure不能随意在函数外调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@noescape使用注意点:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;别修饰的clousure不能用于asynchronously(异步)  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt; class A1 {
        func async(@noescape code:() -&amp;gt; ()) -&amp;gt; Void {
/*报错：error: invalid conversion from non-escaping function of type '@noescape () -&amp;gt; ()' to potentially  escaping function type 'dispatch_block_t' (aka '@convention(block) () -&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/swift-guan-jian-zi-noescape-2/</link><guid isPermaLink="false">d4fc10b6-13a7-484f-9b99-a31d38367650</guid><dc:creator>ioneway</dc:creator><pubDate>Sat, 09 Apr 2016 04:58:46 GMT</pubDate><content:encoded>&lt;p&gt;Swift1.2发布时就已经有这个关键字了。正确使用它可以使我们避免许多不希望的保留环。&lt;/p&gt;

&lt;p&gt;@noescape主要用在对函数中的closure参数修饰。&lt;/p&gt;

&lt;p&gt;使用@noescape修饰closure后，clousure的生命周期要比函数的调用周期短，也就是说clousure不能随意在函数外调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;@noescape使用注意点:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;别修饰的clousure不能用于asynchronously(异步)  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt; class A1 {
        func async(@noescape code:() -&amp;gt; ()) -&amp;gt; Void {
/*报错：error: invalid conversion from non-escaping function of type '@noescape () -&amp;gt; ()' to potentially  escaping function type 'dispatch_block_t' (aka '@convention(block) () -&amp;gt; ()')*/
            dispatch_async(dispatch_get_main_queue(), code); 

        }
    }

 class A2 {
        func async(@noescape code:() -&amp;gt; ()) -&amp;gt; Void {
            dispatch_async(dispatch_get_main_queue(), code);
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;不能进行存储赋给另一个closure变量  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;class A1 {  
        func async(@noescape code:() -&amp;gt; ()) -&amp;gt; Void {
            let codeConst:()-&amp;gt;() = code;
            codeConst()
        }
    }

    class A2 {
        func async(code:() -&amp;gt; ()) -&amp;gt; Void {
            let codeConst:()-&amp;gt;() = code;
            codeConst()
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;不能在另一个非@noescape closure中进行捕获  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;    class A9 {
        func capture(@noescape code: ()-&amp;gt;()) -&amp;gt; Void {
            let captured = {
                code()
            }
            captured()
        }
    }

    class A10 {
        func capture(code: ()-&amp;gt;()) -&amp;gt; Void {
            let captured = {
                code()
            }
            captured()
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;在对所属class或者strutt的其他属性或函数进行操作时无需加&lt;code&gt;self.&lt;/code&gt;  &lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;class A4{  
    var b: (Void -&amp;gt; Void)!
    var k = 0//用来调用的  
    func aa(@noescape a: (Void-&amp;gt;Void)){
        a()
    }
    func bb(){
        aa {
            () -&amp;gt; Void in
            k = 1//一般的closure都是要self.k = 1,@noescape则不需要
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=""&gt;总结&lt;/h4&gt;

&lt;p&gt;@noescape限制了closure的使用范围，当你确定该closure不会在函数外调用时，则最好加上@noescape修饰符，这样可以带来一些性能的提升。同时在引用属性或其他方法时无需加&lt;code&gt;self.&lt;/code&gt;,也避免了循环引用的问题。&lt;/p&gt;</content:encoded></item><item><title>Swift中的map, filter, reduce 函数</title><description>&lt;p&gt;Swift中Array支持三个高阶函数，map, filter和reduce。对于我们对数组进行操作带来了很大的方便。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;高阶函数的定义：满足以下两点其一即为高阶函数：1，接受一个或者多个函数作为输入；2，输出一个函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="map"&gt;map函数&lt;/h3&gt;

&lt;p&gt;map函数的作用：对某一个数组中的元素进行转换，然后产生一个新的数组。 &lt;br&gt;
map函数是CollectionType协议中定义的方法： &lt;br&gt;
&lt;code&gt;public func map&amp;lt;T&amp;gt;(@noescape transform: (Self.Generator.Element) throws -&amp;gt; T) rethrows -&amp;gt; [T]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该定义是一个泛型定义。&lt;/p&gt;

&lt;p&gt;@noescape：用于解除闭包的循环引用，类似[weak self], 但是@noescape不能用于可选类型，因为可选类型实际上是enum，而非closure。 &lt;/p&gt;

&lt;p&gt;Generator.Element 是一个泛型定义，Element代表数组中的类型，它既可以是Int也可以是String等。像是对该泛型起了一个固定的名称叫：&lt;/p&gt;</description><link>http://localhost:2368/swiftzhong-de-map-filter-reduce-han-shu/</link><guid isPermaLink="false">e6f27f98-5da0-4bc7-8f3b-850ab727b5bd</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 07 Apr 2016 13:55:34 GMT</pubDate><content:encoded>&lt;p&gt;Swift中Array支持三个高阶函数，map, filter和reduce。对于我们对数组进行操作带来了很大的方便。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;高阶函数的定义：满足以下两点其一即为高阶函数：1，接受一个或者多个函数作为输入；2，输出一个函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id="map"&gt;map函数&lt;/h3&gt;

&lt;p&gt;map函数的作用：对某一个数组中的元素进行转换，然后产生一个新的数组。 &lt;br&gt;
map函数是CollectionType协议中定义的方法： &lt;br&gt;
&lt;code&gt;public func map&amp;lt;T&amp;gt;(@noescape transform: (Self.Generator.Element) throws -&amp;gt; T) rethrows -&amp;gt; [T]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;该定义是一个泛型定义。&lt;/p&gt;

&lt;p&gt;@noescape：用于解除闭包的循环引用，类似[weak self], 但是@noescape不能用于可选类型，因为可选类型实际上是enum，而非closure。 &lt;/p&gt;

&lt;p&gt;Generator.Element 是一个泛型定义，Element代表数组中的类型，它既可以是Int也可以是String等。像是对该泛型起了一个固定的名称叫：Element，而我们通常自定义泛型多喜欢用T。&lt;/p&gt;

&lt;p&gt;以下是Generator的定义&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public protocol GeneratorType {  
    /// The type of element generated by `self`.
    associatedtype Element
    /// Advance to the next element and return it, or `nil` if no next
    /// element exists.
    ///
    /// - Requires: `next()` has not been applied to a copy of `self`
    ///   since the copy was made, and no preceding call to `self.next()`
    ///   has returned `nil`.  Specific implementations of this protocol
    ///   are encouraged to respond to violations of this requirement by
    ///   calling `preconditionFailure("...")`.
    @warn_unused_result
    public mutating func next() -&amp;gt; Self.Element?
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我门尝试着自己实现map函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//该实现不带有异常处理
func map&amp;lt;T&amp;gt;(transform: Element -&amp;gt; T) -&amp;gt; [T] {  
    var result: [T] = []
    for item in self {
      result.append(transform(item))
    }
    return result
  }

//调用方式：
[1, 2, 3].map { (x) -&amp;gt; Int in
  return x + 1
}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>Shell 脚本学习（－）</title><description>&lt;p&gt;公司一位同事要离职，结果领导就把他负责的一些自动化工作交给我了，说是因为其他的同事都不懂shell，可是我也不懂啊。哎，很无奈，既然任务领导已经决定将任务交给我，那就是对我的信任。就这样对自己安慰着。默默的下载了一本shell入门书籍《Shell脚本学习指南》，先从基础慢慢学着，希望他走之前我可以胜任这份工作。&lt;/p&gt;

&lt;p&gt;废话不多说了，总结一下今天对shell的学习成果。&lt;/p&gt;

&lt;p&gt;shell脚本是一种解释型语言，它有以下优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单性&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
shell可以简洁的表达复杂的操作。  &lt;/li&gt;
&lt;li&gt;可移植性&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
使用POSIX所定义的功能可以无须修改就可以运行在其他系统上。&lt;/li&gt;
&lt;li&gt;开发容易&amp;nbsp;&amp;nbsp;&amp;nbsp;
可以在短时间内完成一个功能强大的好用脚本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;shell识别4种基本命令：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内建命令(build-in)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;内建命令就是由shell本身所执行的命令。一般执行效率较高。例如：read, test, cd, echo, printf等都属于内建命令。  &lt;/li&gt;
&lt;li&gt;shell 函数&lt;br&gt;&amp;nbsp;&lt;/li&gt;&lt;/ol&gt;</description><link>http://localhost:2368/shell-jiao-ben-xue-xi/</link><guid isPermaLink="false">00f5fb6b-f5d0-4114-97ea-e5ca9a15fdf6</guid><dc:creator>ioneway</dc:creator><pubDate>Sat, 02 Apr 2016 03:50:10 GMT</pubDate><content:encoded>&lt;p&gt;公司一位同事要离职，结果领导就把他负责的一些自动化工作交给我了，说是因为其他的同事都不懂shell，可是我也不懂啊。哎，很无奈，既然任务领导已经决定将任务交给我，那就是对我的信任。就这样对自己安慰着。默默的下载了一本shell入门书籍《Shell脚本学习指南》，先从基础慢慢学着，希望他走之前我可以胜任这份工作。&lt;/p&gt;

&lt;p&gt;废话不多说了，总结一下今天对shell的学习成果。&lt;/p&gt;

&lt;p&gt;shell脚本是一种解释型语言，它有以下优势：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简单性&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
shell可以简洁的表达复杂的操作。  &lt;/li&gt;
&lt;li&gt;可移植性&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
使用POSIX所定义的功能可以无须修改就可以运行在其他系统上。&lt;/li&gt;
&lt;li&gt;开发容易&amp;nbsp;&amp;nbsp;&amp;nbsp;
可以在短时间内完成一个功能强大的好用脚本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;shell识别4种基本命令：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;内建命令(build-in)&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;内建命令就是由shell本身所执行的命令。一般执行效率较高。例如：read, test, cd, echo, printf等都属于内建命令。  &lt;/li&gt;
&lt;li&gt;shell 函数&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;shell函数是功能健全的一系列程序代码，可以像命令一样引用执行。  &lt;/li&gt;
&lt;li&gt;外部命令&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;外部命令由shell的副本&amp;lt;新的进程&gt;所执行的命令；  &lt;/li&gt;
&lt;li&gt;系统命令&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;系统命令也属于外部命令，只是系统内部包含而已。有不少系统命令与内建命令名称相同，功能也大体相同。但是效率低于内建命令。例如：echo命令与/bin/echo是两个不同的命令，前者为内建命令，后者为系统命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;其中系统命令也属于外部命令。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=""&gt;内建命令与外部命令&lt;/h3&gt;

&lt;p&gt;内建命令指bash(或者其他版本)工具集中的命令。一般有shell直接执行，不需要产生子进程执行。&lt;/p&gt;

&lt;p&gt;外部命令和系统命令：需要fork出一个子进程执行。&lt;/p&gt;

&lt;h3 id=""&gt;外部命令执行过程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;建立一个新的进程。此进程即为shell的一个副本。&lt;/li&gt;
&lt;li&gt;在新的进程里，在PATH变量内所列出的目录中，寻找特定的命令。/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin为PATH的变量典型的默认值。&lt;/li&gt;
&lt;li&gt;fork一个新的进程取代现有shell进程执行&lt;/li&gt;
&lt;li&gt;程序完成后，最初的shell父进程回接着从终端读取下一条命了，或执行脚本里的下一条命令。
如图&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/04/shell_1_0-1.png" alt=""&gt;&lt;/p&gt;

&lt;h3 id=""&gt;学习到的几个命令&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;：打印命令类型&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Shell"&gt;type echo  
#cd is a shell builtin, cd是内建命令
type /bin/echo  
#/bin/echo is /bin/echo, /bin/echo是系统命令
type -a echo  
#echo is a shell builtin
#echo is /bin/echo
#echo命令有两个，一个是内建，一个是系统命令
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=""&gt;命令的组成部分&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;命令名称 &lt;br&gt;
 命令的第一项，必须有。&lt;/li&gt;
&lt;li&gt;选项 &lt;br&gt;
 选项的开头一般是一个'-'号开头，后跟一个字母。选项并非必须，可有可无。选项有长选项，开头会包含一个或者两个'-'符号，具体由命令本身决定。选项后若无参数可以与其他选项合并。如:&lt;code&gt;ls -lt file.c&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;参数 &lt;br&gt;
 一般跟在选项之后，并非必须，可有可无。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=""&gt;命令分隔符&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多个命令可以写在一行，命令之间需要有';'分号隔开，按序执行，前一个命令执行完毕后再执行下一个命令。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一行中多个命令使用'&amp;amp;'隔开，则shell会在后台执行'&amp;amp;'前的命令，而无需等待期前的命令执行完毕即可直接执行后面的命令。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title>隐藏NavigationBar下边线</title><description>&lt;p&gt;有些app需要将NavigationBar的下边线隐藏，从而使得页面看起导航条和下面的页面融为一体。&lt;/p&gt;

&lt;h2 id="view"&gt;寻找下边线View视图&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;- (UIImageView*)bottomLineView:(UIView*)view {

    if([view isKindOfClass:UIImageView.class] &amp;amp;&amp;amp; view.bounds.size.height&amp;lt;=1.0) {
        return(UIImageView*)view;
    }
    for(UIView*subview in view.subviews) {
        UIImageView*imageView = [self bottomLineView:subview];
        if(imageView) {
            return imageView;
        }
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将该函数作为&lt;code&gt;UINavigationBar&lt;/code&gt;的扩展函数即可直接调用得到盖视图，然后在希望隐藏的地方将&lt;code&gt;hide&lt;/code&gt;属性值为&lt;code&gt;YES&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=""&gt;应用场景：&lt;/h2&gt;</description><link>http://localhost:2368/yin-cang-navigationbarxia-bian-xian-2/</link><guid isPermaLink="false">84809031-9470-47d5-9951-a3d3a82eb1d5</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 24 Mar 2016 03:22:21 GMT</pubDate><content:encoded>&lt;p&gt;有些app需要将NavigationBar的下边线隐藏，从而使得页面看起导航条和下面的页面融为一体。&lt;/p&gt;

&lt;h2 id="view"&gt;寻找下边线View视图&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;- (UIImageView*)bottomLineView:(UIView*)view {

    if([view isKindOfClass:UIImageView.class] &amp;amp;&amp;amp; view.bounds.size.height&amp;lt;=1.0) {
        return(UIImageView*)view;
    }
    for(UIView*subview in view.subviews) {
        UIImageView*imageView = [self bottomLineView:subview];
        if(imageView) {
            return imageView;
        }
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将该函数作为&lt;code&gt;UINavigationBar&lt;/code&gt;的扩展函数即可直接调用得到盖视图，然后在希望隐藏的地方将&lt;code&gt;hide&lt;/code&gt;属性值为&lt;code&gt;YES&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=""&gt;应用场景：&lt;/h2&gt;

&lt;p&gt;1，当页面视图是一个UIScrollView时，在正常状态下隐藏下边线，在用户向上滑动时候显示下边线。&lt;/p&gt;</content:encoded></item><item><title>Swift 最佳实践（一）</title><description>&lt;p&gt;Swift已经问世有一段时间了，各种优秀的第三方库都陆续出现，以及学习网站都加大了对Swift的推广力度，就连一向傲慢的苹果也为推广Swift专门设立了一个Bolg。还有不少大神都发文看好Swift发展。所以为了适应未来，学习Swift迫在眉睫。&lt;/p&gt;

&lt;p&gt;最近看了一个swift项目：CollapsableTable-Swift-master，我已经找不到是从哪里下载的了，为了能够永久保存，不至于误删除，我copy了一份放在了我的百度云中，分享给大家：&lt;a href="http://pan.baidu.com/s/1nux5IaP"&gt;http://pan.baidu.com/s/1nux5IaP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在项目中学习到了一些Swift编写方法和要点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1, 对于一个只申明了方法的protocol，class最好在extention中实现该协议，实现该协议时需要调用的私有方法最好也放在该extention中，这样会使得代码结构清晰。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如项目中的&lt;code&gt;CollapsableTableScene&lt;/code&gt;类在实现&lt;code&gt;CollapsableTableViewSectionHeaderInteractionProtocol&lt;/code&gt;协议的时候是这样写的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension CollapsableTableViewController: CollapsableTableViewSectionHeaderInteractionProtocol {  
//相关实现......
}

private fund indexPaths(...){  
//私有方法实现
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类在实现对应协议的时候，将所有相关函数都放入了对应的extention中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2，当一个条件不满足就需要return结束函数，最好使用guard[条件取反] else { }&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如项目中：&lt;code&gt;CollapsableTableViewController&lt;/code&gt;的ViewDidLoad函数的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/swift-si-kao-yi/</link><guid isPermaLink="false">784723ee-9ce5-4d2d-a739-99df90748a09</guid><dc:creator>ioneway</dc:creator><pubDate>Wed, 23 Mar 2016 04:23:00 GMT</pubDate><content:encoded>&lt;p&gt;Swift已经问世有一段时间了，各种优秀的第三方库都陆续出现，以及学习网站都加大了对Swift的推广力度，就连一向傲慢的苹果也为推广Swift专门设立了一个Bolg。还有不少大神都发文看好Swift发展。所以为了适应未来，学习Swift迫在眉睫。&lt;/p&gt;

&lt;p&gt;最近看了一个swift项目：CollapsableTable-Swift-master，我已经找不到是从哪里下载的了，为了能够永久保存，不至于误删除，我copy了一份放在了我的百度云中，分享给大家：&lt;a href="http://pan.baidu.com/s/1nux5IaP"&gt;http://pan.baidu.com/s/1nux5IaP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在项目中学习到了一些Swift编写方法和要点。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1, 对于一个只申明了方法的protocol，class最好在extention中实现该协议，实现该协议时需要调用的私有方法最好也放在该extention中，这样会使得代码结构清晰。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如项目中的&lt;code&gt;CollapsableTableScene&lt;/code&gt;类在实现&lt;code&gt;CollapsableTableViewSectionHeaderInteractionProtocol&lt;/code&gt;协议的时候是这样写的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension CollapsableTableViewController: CollapsableTableViewSectionHeaderInteractionProtocol {  
//相关实现......
}

private fund indexPaths(...){  
//私有方法实现
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类在实现对应协议的时候，将所有相关函数都放入了对应的extention中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2，当一个条件不满足就需要return结束函数，最好使用guard[条件取反] else { }&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如项目中：&lt;code&gt;CollapsableTableViewController&lt;/code&gt;的ViewDidLoad函数的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;guard let tableView = collapsableTableView() else {  
            return
        }
//.....非空执行
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不使用guard，那么就需要隐式解包：如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       let tableView = collapsableTableView()
        if tableView == nil{
            return;
        }
//而之后使用tableView也需要解绑tableView!.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;      if let tableView = collapsableTableView()  {
            //.....非空之行
        }else{
            return;
        };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的话代码结构就不再清晰,容易误导读者。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;3，千万不要为一个声明为！的值，在其后添加？来调用它的实例函数。因为该值如果没有被赋值，在其后添加？调用方法则会忽略方法调用，而不会crash。导致bug难以查找。&lt;/p&gt;
  
  &lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;声明为！的属性，如果没有在init方法中或者在声明的时候赋初始值，编译器不会报错也不会有警告。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如项目中：&lt;code&gt;MenuSectionHeader&lt;/code&gt;类中的&lt;code&gt;interactionDelegate&lt;/code&gt;声明为！值，但是又在touchesEnded方法中这样调用：&lt;code&gt;interactionDelegate?.userTappedView(self, atPoint: touch.locationInView(self)).&lt;/code&gt; 如果在interactionDelegate忘记被赋值，则userTappedView就会被忽略掉。程序bug就会比较难找。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;我认为这是项目中Swift使用的一个缺陷。应当去除?. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本人iOS菜鸟一个，正在不断学习中。&lt;/p&gt;

&lt;p&gt;以上仅是个人想法，如有缺陷欢迎指正。&lt;/p&gt;

&lt;p&gt;谢谢。&lt;/p&gt;</content:encoded></item><item><title>Swift 初始化器</title><description>&lt;p&gt;Swift初始化器有两种：指定初始化器&lt;code&gt;(Designated Initializer)&lt;/code&gt;和便利初始化器&lt;code&gt;(Convenience Initializer)&lt;/code&gt;. &lt;/p&gt;

&lt;h4 id="designatedinitializer"&gt;指定初始化器&lt;designated initializer=""&gt;&lt;/designated&gt;&lt;/h4&gt;

&lt;p&gt;指定初始化器是类的最主要的初始化器，它会将类中所有属性赋值初始化，并且一路往上调用父类的&lt;strong&gt;指定初始化器&lt;/strong&gt;去初始化它们各自引入的属性。&lt;u style="color:red"&gt;&lt;b&gt;类有且至少要有一个指定初始化器&lt;/b&gt;&lt;/u&gt;。&lt;/p&gt;

&lt;h4 id="convenienceinitializer"&gt;便利初始化器&lt;convenience initializer=""&gt;&lt;/convenience&gt;&lt;/h4&gt;

&lt;p&gt;便利初始化器就是方便开发者调用的初始化器，它必须调用同个类的指定初始化器，提供一些默认的参数给指定初始化器来生成一个默认的类的实例。&lt;u style="color:red"&gt;&lt;b&gt;一个类可以没有便利初始化器&lt;/b&gt;&lt;/u&gt;。&lt;/p&gt;

&lt;p&gt;初始化器之间的相互调用关系，必须遵守一下原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;b style="color:red"&gt;指定初始化器必须调用其父类的指定初始化器&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;b style="color:red"&gt;便利初始化器必须调用该类中另一个初始化器&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;b style="color:red"&gt;便利初始化器最终必须调用一个指定初始化器&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;简单说：就是指定初始化器必须在类的继承关系中一路向上调用，便利初始化器必须在该类中一路往指定初始化器调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/03/init__use.png" alt="init_use"&gt;&lt;/p&gt;</description><link>http://localhost:2368/swift-chu-shi-hua-qi/</link><guid isPermaLink="false">699af059-09ff-4996-9739-3e857d329570</guid><dc:creator>ioneway</dc:creator><pubDate>Tue, 15 Mar 2016 05:20:36 GMT</pubDate><content:encoded>&lt;p&gt;Swift初始化器有两种：指定初始化器&lt;code&gt;(Designated Initializer)&lt;/code&gt;和便利初始化器&lt;code&gt;(Convenience Initializer)&lt;/code&gt;. &lt;/p&gt;

&lt;h4 id="designatedinitializer"&gt;指定初始化器&lt;designated initializer=""&gt;&lt;/designated&gt;&lt;/h4&gt;

&lt;p&gt;指定初始化器是类的最主要的初始化器，它会将类中所有属性赋值初始化，并且一路往上调用父类的&lt;strong&gt;指定初始化器&lt;/strong&gt;去初始化它们各自引入的属性。&lt;u style="color:red"&gt;&lt;b&gt;类有且至少要有一个指定初始化器&lt;/b&gt;&lt;/u&gt;。&lt;/p&gt;

&lt;h4 id="convenienceinitializer"&gt;便利初始化器&lt;convenience initializer=""&gt;&lt;/convenience&gt;&lt;/h4&gt;

&lt;p&gt;便利初始化器就是方便开发者调用的初始化器，它必须调用同个类的指定初始化器，提供一些默认的参数给指定初始化器来生成一个默认的类的实例。&lt;u style="color:red"&gt;&lt;b&gt;一个类可以没有便利初始化器&lt;/b&gt;&lt;/u&gt;。&lt;/p&gt;

&lt;p&gt;初始化器之间的相互调用关系，必须遵守一下原则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;b style="color:red"&gt;指定初始化器必须调用其父类的指定初始化器&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;b style="color:red"&gt;便利初始化器必须调用该类中另一个初始化器&lt;/b&gt;&lt;/li&gt;
&lt;li&gt;&lt;b style="color:red"&gt;便利初始化器最终必须调用一个指定初始化器&lt;/b&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;简单说：就是指定初始化器必须在类的继承关系中一路向上调用，便利初始化器必须在该类中一路往指定初始化器调用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/03/init__use.png" alt="init_use"&gt;&lt;/p&gt;</content:encoded></item><item><title>Swift 中Enums, Structs, Classes的理解</title><description>&lt;p&gt;原文地址：&lt;a href="https://www.raywenderlich.com/119881/enums-structs-and-classes-in-swift"&gt;https://www.raywenderlich.com/119881/enums-structs-and-classes-in-swift&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;回想只使用OC语言进行开发的时候，&lt;code&gt;封装&lt;/code&gt;功能被限制在类中。然而，现在可以使用Swift进行开发，&lt;code&gt;enums&lt;/code&gt;, &lt;code&gt;structs&lt;/code&gt;和&lt;code&gt;classes&lt;/code&gt;同样也具有了封装的功能。&lt;/p&gt;

&lt;p&gt;这些类型和&lt;code&gt;protocols&lt;/code&gt;结合，会创造出令人惊奇的功能。他们有许多共同的功能，也有不少重要的区别。&lt;/p&gt;

&lt;p&gt;本教程的目的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;介绍一些enums,structs和classes的使用经验。&lt;/li&gt;
&lt;li&gt;当你使用它们的时候，能帮你解决一些问题。&lt;/li&gt;
&lt;li&gt;介绍他们是如何工作的。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在读取本教程之前请确定你已经对Swift有了一些了解并具有一些面向对象的经验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;概览&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;最大的卖点是：&lt;code&gt;safety&lt;/code&gt;, &lt;code&gt;speed&lt;/code&gt;, &lt;code&gt;simplicity&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Safety&lt;/strong&gt;意味着你很难因为"不小心","不按常规","记忆不清"儿写出难以发现的bug。&lt;strong&gt;Swift&lt;/strong&gt;使你的开发工作更加安全，因为他会试图在编译阶段报告你的bug，而不是在运行时阶段挂掉你的app。&lt;/p&gt;

&lt;p&gt;此外，Swift可以是你的代码更加干净明了并易于理解，优化器可以使应用运行的更快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;&lt;/p&gt;</description><link>http://localhost:2368/swift-zhong-enums-structs-classesde-li-jie/</link><guid isPermaLink="false">b6ebab49-d473-41ae-b67e-d9db177e9e93</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 10 Mar 2016 04:54:06 GMT</pubDate><content:encoded>&lt;p&gt;原文地址：&lt;a href="https://www.raywenderlich.com/119881/enums-structs-and-classes-in-swift"&gt;https://www.raywenderlich.com/119881/enums-structs-and-classes-in-swift&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;回想只使用OC语言进行开发的时候，&lt;code&gt;封装&lt;/code&gt;功能被限制在类中。然而，现在可以使用Swift进行开发，&lt;code&gt;enums&lt;/code&gt;, &lt;code&gt;structs&lt;/code&gt;和&lt;code&gt;classes&lt;/code&gt;同样也具有了封装的功能。&lt;/p&gt;

&lt;p&gt;这些类型和&lt;code&gt;protocols&lt;/code&gt;结合，会创造出令人惊奇的功能。他们有许多共同的功能，也有不少重要的区别。&lt;/p&gt;

&lt;p&gt;本教程的目的是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;介绍一些enums,structs和classes的使用经验。&lt;/li&gt;
&lt;li&gt;当你使用它们的时候，能帮你解决一些问题。&lt;/li&gt;
&lt;li&gt;介绍他们是如何工作的。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;在读取本教程之前请确定你已经对Swift有了一些了解并具有一些面向对象的经验。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=""&gt;概览&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;最大的卖点是：&lt;code&gt;safety&lt;/code&gt;, &lt;code&gt;speed&lt;/code&gt;, &lt;code&gt;simplicity&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Safety&lt;/strong&gt;意味着你很难因为"不小心","不按常规","记忆不清"儿写出难以发现的bug。&lt;strong&gt;Swift&lt;/strong&gt;使你的开发工作更加安全，因为他会试图在编译阶段报告你的bug，而不是在运行时阶段挂掉你的app。&lt;/p&gt;

&lt;p&gt;此外，Swift可以是你的代码更加干净明了并易于理解，优化器可以使应用运行的更快。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Swift&lt;/strong&gt;语言核心简单且高度正规化，它仅仅建立在很少量的几个核心概念之上。尽管它的规则相对简单，但是功能却十分强大。&lt;/p&gt;

&lt;p&gt;使其简单且功能强大的重要原因是Swift的类型系统&lt;code&gt;type system&lt;/code&gt;
&lt;img src="http://localhost:2368/content/images/2016/03/types-700x195.png" alt="types system"&gt;&lt;/p&gt;

&lt;p&gt;Swift的类型系统十分强大，尽管它只有6种类型。它不像一些其它语言一样字面上拥有十多种类型，而Swift只有6种。&lt;/p&gt;

&lt;p&gt;四种组合类型：protocol, enum, struct, class. 两种复合类型：tuple, function.&lt;/p&gt;

&lt;p&gt;还有一些基础类型：Bool, Int, Uint, Float, Double, Character, String ,Array, Set, Dictionary, Optional, 等。然而，这些类型都来自标准库。&lt;/p&gt;

&lt;p&gt;本教程以model types为基础的组合类型enum, struct和class为重点。&lt;/p&gt;

&lt;h1 id=""&gt;开始&lt;/h1&gt;

&lt;p&gt;创建一个playground项目并命名为&lt;strong&gt;Shapes&lt;/strong&gt;,选择平台为OS X.清除现有代码，并加入以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用字符串虽然简单，但是也有一些重要的缺陷：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;容易出错。任何不属于颜色规格的字符串都会正常编译，但是在运行时报错。  &lt;/li&gt;
&lt;li&gt;Autocomplete不能正确的帮助你检测颜色名称。  &lt;/li&gt;
&lt;li&gt;当你传递一个颜色字符串参数时，它可能不能明确的表明这是一个代表颜色的字符串。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=""&gt;使用枚举来解决&lt;/h3&gt;

&lt;p&gt;使用自定义类型来解决这些问题。如果你来自Cocoa Touch，你可能想实现一个封装的类像UIColor。而Swift提供给您更多的选择来定义您的模型。&lt;/p&gt;

&lt;p&gt;在实现这个功能之前，先让我们想想如何实现颜色enum，你可能会想到用以下代码来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum ColorName {  
  case Black
  case Silver
  case Gray
  case White
  case Maroon
  case Red
  // ... and so on ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上方式十分类似于C-style enums.然而，Swift允许你指定一个类型来表示每一个case。当然，被指定的类型必须遵守RawRepresentable协议。&lt;/p&gt;

&lt;p&gt;所以你可以如下创建颜色枚举，并为每一个case赋值:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum ColorName : String {  
  case Black  = "Black"
  case Silver = "Silver"
  case Gray   = "Gray"
  case White  = "White"
  case Maroon = "Maroon"
  case Red    = "Red"
  // ... and so on ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift在使用字符串作为枚举值的时候有其特殊性。如果你没有制定case的值，那么编译器会自动为其赋值，值为case的名称。这意味着你可以像下面这样写：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum ColorName : String {  
  case Black
  case Silver
  case Gray
  case White
  case Maroon
  case Red
  // ... and so on ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以通过只写一次&lt;code&gt;case&lt;/code&gt;并使用逗号来分割case来简化enum。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum ColorName : String {  
  case Black, Silver, Gray, White, Maroon, Red, Purple, Fuchsia, Green, Lime, Olive, Yellow, Navy, Blue, Teal, Aqua
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你在对于使用字符串来表示颜色所遇到的问题就解决了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let fill = ColorName.Grey   // ERROR: Misspelled color names won't compile. Good!  
let fill = ColorName.Gray   // Correct names autocomplete and compile. Yay!  
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="associatedvalues"&gt;关联值(Associated Values)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;ColorName&lt;/strong&gt;是命名Color的model。但是如果你希望像CSS中的那样可以有多种表现形式：名称，RGB, HSL 等等。如何为他们建模呢？&lt;/p&gt;

&lt;p&gt;Swift中Enum对于建模十分强大，可以表现各种东西，如：CSS颜色，并且这些enum case与他们的值相关联。这些值成为关联值&lt;code&gt;(Associated Values)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用enum来定义&lt;strong&gt;CSSColor&lt;/strong&gt;，向playground添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum CSSColor {  
  case Named(ColorName)
  case RGB(UInt8, UInt8, UInt8)
}
&lt;/code&gt;&lt;/pre&gt;</content:encoded></item><item><title>iOS 7 SDK: 多任务的改进</title><description>&lt;p&gt;原文地址：&lt;a href="http://code.tutsplus.com/tutorials/ios-7-sdk-multitasking-enhancements--mobile-20295"&gt;http://code.tutsplus.com/tutorials/ios-7-sdk-multitasking-enhancements--mobile-20295&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇教程向我们介绍iOS7 SDK中多任务的改进，具体来说，你将了解到Background Fetch, Remote Notifications, 和Background Transfer Service APIs。&lt;/p&gt;

&lt;h2 id=""&gt;&lt;strong&gt;多任务概述&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;iOS7中，Apple新加了3类新的mutltitasking APIs：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Background Fetch&lt;/li&gt;
&lt;li&gt;Remote Notifications&lt;/li&gt;
&lt;li&gt;Background Transfer Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些APIs可以使程序员更充分的利用硬件特性完成多任务，以向用户提供跟好的用户体验。本教程会教你跟多关于上述三个改进，以及什么时候该使用他们。&lt;/p&gt;

&lt;h1 id="backgroundfetch"&gt;Background Fetch&lt;/h1&gt;

&lt;p&gt;为了使Background Fetch API更加易于理解，想像一下你想建立一个新闻类app，该类应用
的内容由网络提供，会有一个重要的特点就是每次用户打开app都要跟新内容。&lt;/p&gt;

&lt;p&gt;在iOS7之前，开发者会在app启动的时候获取跟新内容。这样做有一个缺陷，就是用户在需要在启动app后等待一段时间，等待时间也要受到手机的连接速度的影响。试想一下，如果用户在一两个星期没有使用后，通过蜂窝网打开app会需要等多久。&lt;/p&gt;</description><link>http://localhost:2368/ios-7-sdk-duo-ren-wu-de-gai-jin/</link><guid isPermaLink="false">0dcc7a07-1f8a-441e-9289-581c0cf5349f</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 18 Feb 2016 06:55:29 GMT</pubDate><content:encoded>&lt;p&gt;原文地址：&lt;a href="http://code.tutsplus.com/tutorials/ios-7-sdk-multitasking-enhancements--mobile-20295"&gt;http://code.tutsplus.com/tutorials/ios-7-sdk-multitasking-enhancements--mobile-20295&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇教程向我们介绍iOS7 SDK中多任务的改进，具体来说，你将了解到Background Fetch, Remote Notifications, 和Background Transfer Service APIs。&lt;/p&gt;

&lt;h2 id=""&gt;&lt;strong&gt;多任务概述&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;iOS7中，Apple新加了3类新的mutltitasking APIs：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Background Fetch&lt;/li&gt;
&lt;li&gt;Remote Notifications&lt;/li&gt;
&lt;li&gt;Background Transfer Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些APIs可以使程序员更充分的利用硬件特性完成多任务，以向用户提供跟好的用户体验。本教程会教你跟多关于上述三个改进，以及什么时候该使用他们。&lt;/p&gt;

&lt;h1 id="backgroundfetch"&gt;Background Fetch&lt;/h1&gt;

&lt;p&gt;为了使Background Fetch API更加易于理解，想像一下你想建立一个新闻类app，该类应用
的内容由网络提供，会有一个重要的特点就是每次用户打开app都要跟新内容。&lt;/p&gt;

&lt;p&gt;在iOS7之前，开发者会在app启动的时候获取跟新内容。这样做有一个缺陷，就是用户在需要在启动app后等待一段时间，等待时间也要受到手机的连接速度的影响。试想一下，如果用户在一两个星期没有使用后，通过蜂窝网打开app会需要等多久。这显然不是开发者所希望的，因为这会影响用户体验。&lt;/p&gt;

&lt;p&gt;在iOS7及其之后，这种情况会得到彻底改变。使用Background Fetch API可以使app在后台被动下载跟新内容。iOS会唤醒app，并分配后台时间，当app完成跟新后就又会回到休眠状态。当然，当发生跟新时，用户不会接到通知。当他们返回应用的时候，他们将看到的是跟新后的内容。&lt;/p&gt;

&lt;p&gt;更新过程可以在任一由程序员或由系统预定的时间间隔发生。如果你选择自定义间隔，苹果建议你应该设置更大的间隔，而不是过于平凡的后台获取。太小的间隔，太频繁的跟新会浪费电池和系统资源。如果采用系统设置的时间间隔，那么iOS7会自己更具情况设置。它将会更具用户启动这款app频率以及启动的时间来预测。例如，一款news app，用户一般启动它的时间在每天下午，那么iOS系统会决定应用程序应该在平时下午启动应用时间之前的一段时间进行跟新。非常的智能且节省。&lt;/p&gt;

&lt;p&gt;以上描述的Background Fetch包括以下三步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开Background Fetch capability  &lt;/li&gt;
&lt;li&gt;设置最小间隔  &lt;/li&gt;
&lt;li&gt;执行代理方法：&lt;code&gt;application:performFetchWithCompletionHandler:&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;来了解一下跟详细的内容。
正如我刚才提到的第一步：打开Background Fetch capability，可以通过Xcode5来完成有两种方式。第一种方式是通过.plist文件，你需要添加一个key为：Required background modes，value为“fetch”的。像下面这样：
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_1_plist_fetch.png" alt="gt7_1_plist_fetch.png"&gt;&lt;/p&gt;

&lt;p&gt;下面的步骤是另外一个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;点击Xcode左侧栏目的project;&lt;/li&gt;
&lt;li&gt;点击中间窗口的&lt;strong&gt;Capabilities&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;选择Background Fetch单选框
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_2_capabilities_fetch.png" alt="gt7_2_capabilities_fetch.png"&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下，初始间隔值被设定为：&lt;code&gt;UIApplicationBackgroundFetchIntervalNever&lt;/code&gt;,这意味着Background Fetch将永远不会执行。如果不改变该值，那么将不会起作用。你需要在&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt; 重新设置该值。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Objc"&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    [application setMinimumBackgroundFetchInterval:UIApplicationBackgroundFetchIntervalMinimum];

    return YES;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;值：UIApplicationBackgroundFetchIntervalMinimum是由系统控制间隔时间且是允许的最小的间隔时间。当然，你也可以通过以上方法设置一个&lt;code&gt;NSTimeInterval&lt;/code&gt;类型的值作为自定义的时间间隔。然而，除非必要，最好还是应该由系统控制Background Fetch的执行时间间隔。但是，即便你设置了&lt;code&gt;UIApplicationBackgroundFetchIntervalMinimum&lt;/code&gt;,你也要清楚的知道，它不是一种绝对的时序安排，它更像是一种建议，iOS系统会尽可能的这么做，但是也会依据当前的可用系统资源来决定。所以Background Fetch的执行次数会少于或者多于我们的预期。&lt;/p&gt;

&lt;p&gt;最后一步是实现新添加的方法：&lt;code&gt;application:performFetchWithCompletionHandler:&lt;/code&gt; 当background fetch执行的时候，该方法开始执行。该方法的回调函数会收到以下三种值：
1. &lt;code&gt;UIBackgroundFetchResultNewData:&lt;/code&gt;如果获取到了新内容 &lt;br&gt;
2. &lt;code&gt;UIBackgroundFetchResultNoData:&lt;/code&gt;没有获取到内容 &lt;br&gt;
3. &lt;code&gt;UIBackgroundFetchResultFailed:&lt;/code&gt;发生错误，获取失败&lt;/p&gt;

&lt;p&gt;请看以下操作：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;-(void)application:(UIApplication *)application performFetchWithCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{

    // Call or write any code necessary to get new data, process it and update the UI.

    // The logic for informing iOS about the fetch results in plain language:
    if (/** NEW DATA EXISTS AND WAS SUCCESSFULLY PROCESSED **/) {
        completionHandler(UIBackgroundFetchResultNewData);
    }

    if (/** NO NEW DATA EXISTS **/) {
        completionHandler(UIBackgroundFetchResultNoData);
    }

    if (/** ANY ERROR OCCURS **/) {
        completionHandler(UIBackgroundFetchResultFailed);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在新数据被发现时，你必须进行必要的用户界面跟新。必须立刻更新用户界面的原因有两个：1》用户应该在打开应用的时候可以看到更新的内容，而无需任何等待(包括加载时间的等待)；2》app的快照也会保持为更新状态。&lt;/p&gt;

&lt;p&gt;这里有几点需要你注意：首先，当app开始从后台执行任务，它只有30秒的时间完成必须的任务。如果30秒时间到了，app将会被再次挂起。如果app需要跟多的时间(比如媒体下载)来执行任务，你应该使用Background Transfer Service API来执行后台获取。我们之后会讲到这个。&lt;/p&gt;

&lt;p&gt;你在做好了Background Fetch的编码后，APPle提供了两种方法来测试你的Background Fetch功能：&lt;/p&gt;

&lt;p&gt;第一种方法有以下步骤：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;像往常一样在模拟器上运行app&lt;/li&gt;
&lt;li&gt;当app运行后，回到Xcode&lt;/li&gt;
&lt;li&gt;点击菜单栏：Debug &gt; Simulate Background Fetch &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种方法在app运行时候测试API非常有效。第二种方式要复杂多，但是他允许你的app在后台时测试：参考以下步骤：
* 打开Schemes列表，点击Manage Schemes...选项。
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_3_manage_schemes.png" alt="gt7_3_manage_schemes.png"&gt;
* 确定选择了当前Scheme，然后复制它：点击窗口下方的齿轮按钮，选择Duplicate
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_4_duplicate_scheme.png" alt="gt7_4_duplicate_scheme.png"&gt;
* 为复制的Scheme设置一个名称。
* 选择左侧列表的&lt;strong&gt;Run&lt;/strong&gt;，然后点击&lt;strong&gt;Options&lt;/strong&gt;。
* 选择&lt;em&gt;*Launch due to a background fetch event *&lt;/em&gt;单选框，点击OK。
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_5_scheme2.png" alt="gt7_5_scheme2.png"&gt;
* 运行复制的Scheme。&lt;/p&gt;

&lt;p&gt;Background fetch只是用与非关键的更新，所以它们跟新的时间不确定。对于关键的更新，请查看 Remote Notifications 部分的内容。一般Background fetch是适合那些希望无缝地管理内容的app，比如展示类的应用：如：新闻，社交网络，天气，图片共享等。&lt;/p&gt;

&lt;h1 id="remotenotifications"&gt;Remote Notifications&lt;/h1&gt;

&lt;p&gt;试想一下，我们要构建一个提供书面和视屏教程的应用。我们假设用户每个月会下载新的视屏教程2到3次。所以，我们该如何让用户知道有新的视屏发布呢？我们不能采用 background fetch API或者类似的东西，因为这会浪费硬件资源和无意义的数据请求。我们也无法知道什么时候一个新的视屏教程会发布。因此，我们需要使用Push Notifications，因此每次有新的内容的时候，我们可以简单地通知用户。我们也希望用户能频繁的启动app并下载新的内容，如果内容很大，他们将需要等很长的时间。因此，当有新内容可用的时候，用户如何才能保持最新的内容而又不需要等待呢？&lt;/p&gt;

&lt;p&gt;Remote Notifications可以在这里派上作用，Remote Notifications实际上是静默通知，也就是说发送通知，却又不让用户知道通知的存在。当一个新的Remote Notifications到达，系统静默地唤醒app，所以此时app可以执行notification。然后app负责启动下载进程更新内容.当完成下载后，本地通知发送给用户。当应用启动时，新的内容已经在等待用户了。&lt;/p&gt;

&lt;p&gt;就像Background Fetch一样，Remote Notifications目的是消除在下载新内容和上传数据时面对的长时间等待的问题。他们的APIs都是在后台线程工作，完成工作后通知用户。然而，Remote Notifications更加适合用在不太频繁的更新或者是非常影响用户体验的情况下。&lt;/p&gt;

&lt;p&gt;要在APP中使用Remote Notifications，你必须先激活它们。你可以通过.plist文件或者Capabilities Tab来完成。如果你要使用.plist文件的方式，你需要添加key：&lt;strong&gt;Required Background&lt;/strong&gt;，value： &lt;strong&gt;remote-notification&lt;/strong&gt;， 像下面这样：
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_6_plist_remote.png" alt="gt7_6_plist_remote.png"&gt;&lt;/p&gt;

&lt;p&gt;要使用Capabilities tab方式，需要以下步骤：
* 点击左侧上面的project
* 点击中间窗口的&lt;strong&gt;Capabilities&lt;/strong&gt;导航条
* 打开&lt;strong&gt;Background Modes&lt;/strong&gt;选项，选择&lt;strong&gt;Remote Notifications&lt;/strong&gt;单选框
&lt;img src="http://localhost:2368/content/images/2016/02/gt7_7_capabilities_remote.png" alt="gt7_7_capabilities_remote.png"&gt;&lt;/p&gt;

&lt;p&gt;下一步是实现方法：&lt;code&gt;application:didReceiveRemoteNotification:fetchCompletionHandler:&lt;/code&gt;. 该方法会在新通知到达的时候调用。使用完成回调方法来通知iOS获取数据的结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;-(void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler{

    // Call or write any code necessary to download new data.

    completionHandler(UIBackgroundFetchResultNewData);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想要静默通知非常简单。在notification载体，你只需要加入一句：&lt;code&gt;code-available: 1&lt;/code&gt; 就会忽略任何形式的提示。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aps{  
   content-available: 1
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在一般情况下，一切与后台获取工作时，其有效期也适用于此。
例如，你最多只有30秒下载新的内容并在app休眠前利用以上方法通知用户，
如果新内容需要更多的下载时间，那么需要考虑使用Background Transfer Service API。&lt;/p&gt;

&lt;p&gt;请注意，苹果控制着remote notification(silent push notifications) 发送的频率，如果频率正常，那么将正常传送。然而如果频率过高，APNs会存储它们，稍后发送。请确保你合理使用远程通知。&lt;/p&gt;

&lt;h2 id="backgroundtransferservice"&gt;Background Transfer Service&lt;/h2&gt;

&lt;p&gt;iOS7另一个重要功能：&lt;strong&gt;Background Transfer Service API&lt;/strong&gt;. 过去，发送或者接收大块数据并不是那么容易，主要是由于运行时间和传输数据的管控的限制。app可以在前台完成大部分的上传和下载数据的需求。然后，iOS7的到来，事情将完全不同，执行后台任务时，app可以有更大的自由。首先，使用Background Transfer Service，应用可以有足够的时间去完成传输任务，而它们是处于前台还是后台无关紧要。时间的限制不在存在。Background Transfer Service会负责管理上传和下载数据。即使应用没有在运行，iOS系统也会唤醒它做出响应。&lt;/p&gt;

&lt;p&gt;Background Transfer Service是以NSURLSession类为基础的，NSURLSession在iOS7时出现。该类通过HTTP和HTTPS传输数据，还提供了后台网络传输相关任务的能力。它背后的思想很简单，它时基于会话(session)的，一个会话管理相关数据的传输任务。有各种可用的session类型，但是我们这里需要了解的是后台sessions，而且它总是工作在系统创建的单独的线程上。后台会话类型包括：&lt;code&gt;NSURLSessionDownloadTask&lt;/code&gt;和&lt;code&gt;NSURLSes`ssionUploadTask&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;另一个值得注意的事情是： background transfers 分为两个模式：discretionary和non-discretionary。Non-discretionary只能初始化在app前台。但是有一个选项可以更具应用的需要设置为discretionary状态。相比之下Discretionary transfers 更加好用，因为这些允许操作系统实现更高效的能量管理。当然on discretionary transfer有一个限制就是只能WI-FI下传输。后台传输尝尝使用discretionary模式。&lt;/p&gt;

&lt;p&gt;代理方法：&lt;code&gt;application:handleEventsForBackgroundURLSession:completionHandler:&lt;/code&gt;在后台传输完成后被调用来完成回调。&lt;/p&gt;

&lt;h3 id=""&gt;&lt;strong&gt;未完，待续&lt;/strong&gt;&lt;/h3&gt;</content:encoded></item><item><title>如何检测任意view的subviews的关系树</title><description>&lt;p&gt;原文地址：&lt;a href="http://www.glimsoft.com/01/07/how-to-inspect-subviews-hierarchy-of-any-uiview/"&gt;http://www.glimsoft.com/01/07/how-to-inspect-subviews-hierarchy-of-any-uiview/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本程序设计教程（或指南，如果你希望如此），我要解释一个简单的方式打印出任何UIView整个子视图层次（子类）。我们要通过创建UIView类，并添加一个递归方法来查看整个树结构。&lt;/p&gt;

&lt;p&gt;现在，可能有人想知道什么是‘category’：它是一种不需要继承任何类来向类中添加方法的一种简洁方式。想了解更多可以参考官方文档：&lt;a href="http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/objectivec/chapters/occategories.html"&gt;documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在某些情况下，当你在寻找一些基础的东西，比如MKMapView的组成；为了修改某些标签，等等，我觉得这种情况很多，所以没有必要再举例了。&lt;/p&gt;

&lt;p&gt;以下是我们的一个category(file UIView+printSubviews.h)：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;


@interface UIView (PrintSubviews)

- (void)printSubviewsWithIndentation:(int)indentation;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Objective-C的Category声明十分简单且重要。更重要的是我们的方法可以在任何UIView及其子类(&lt;/p&gt;</description><link>http://localhost:2368/ru-he-jian-ce-ren-yi-viewde-subviewsde-guan-xi-shu/</link><guid isPermaLink="false">42123b1c-bd2b-401f-8693-add057cec231</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 18 Feb 2016 06:47:50 GMT</pubDate><content:encoded>&lt;p&gt;原文地址：&lt;a href="http://www.glimsoft.com/01/07/how-to-inspect-subviews-hierarchy-of-any-uiview/"&gt;http://www.glimsoft.com/01/07/how-to-inspect-subviews-hierarchy-of-any-uiview/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本程序设计教程（或指南，如果你希望如此），我要解释一个简单的方式打印出任何UIView整个子视图层次（子类）。我们要通过创建UIView类，并添加一个递归方法来查看整个树结构。&lt;/p&gt;

&lt;p&gt;现在，可能有人想知道什么是‘category’：它是一种不需要继承任何类来向类中添加方法的一种简洁方式。想了解更多可以参考官方文档：&lt;a href="http://developer.apple.com/library/ios/#documentation/cocoa/conceptual/objectivec/chapters/occategories.html"&gt;documentation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在某些情况下，当你在寻找一些基础的东西，比如MKMapView的组成；为了修改某些标签，等等，我觉得这种情况很多，所以没有必要再举例了。&lt;/p&gt;

&lt;p&gt;以下是我们的一个category(file UIView+printSubviews.h)：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;


@interface UIView (PrintSubviews)

- (void)printSubviewsWithIndentation:(int)indentation;

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Objective-C的Category声明十分简单且重要。更重要的是我们的方法可以在任何UIView及其子类(UIScrollView, MKMapView, UITableView, UIButton 等等)中工作。现在看看category的实现文件，如下代码：  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;#import "UIView+printSubviews.h"


@implementation UIView (PrintSubviews)

- (void)printSubviewsWithIndentation:(int)indentation {

    // Get all the subviews of the current view
    NSArray *subviews = [self subviews];   

    // Loop through the whole subviews array. We are using the plain-old C-like for loop,
    // just for its simplicity and also to be provided with the iteration number
    for (int i = 0; i &amp;lt; [subviews count]; i++) {

        // Get the subview at current index
        UIView *currentSubview = [subviews objectAtIndex:i];   

        // We will create our description using this mutable string
        NSMutableString *currentViewDescription = [[NSMutableString alloc] init];

        // Indent the actual description to provide visual clue of  how deeply is the current view nested
        for (int j = 0; j &amp;lt;= indentation; j++) {
            [currentViewDescription appendString:@"   "];
        }

        // Construct the actual description string. Note that we are using just index of the current view
        // and name of its class, but it's up to you to print anything you are interested in
        // (for example the frame property using the NSStringFromCGRect(currentSubview.frame) )
        [currentViewDescription appendFormat:@"[%d]: class: '%@'", i, NSStringFromClass([currentSubview class])];

        // Log the description string to the console
        NSLog(@"%@", currentViewDescription);

        // Be good memory citizen
        [currentViewDescription release];

        // the 'recursiveness' nature of this method. Call it on the current subview, with greater indentation
        [currentSubview printSubviewsWithIndentation:indentation+1];
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我觉得不需要作太多的解释，因为十分的简单。现在我将给大家展示一个使用实例，以及该方法所产生的输出。我要在一个有多个annotations，其中一个annotation被选中并弹出callout view的MKMapView上使用改方法。&lt;/p&gt;

&lt;p&gt;首先你需要在你将要使用的类中引入这个category的头文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;#import "UIView+printSubviews.h"
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在你希望检测的view上调用&lt;code&gt;-printSubviewsWithIndentation:&lt;/code&gt;方法&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;NSLog(@"*** Printing out all the subviews of MKMapView ***");  
[mapView printSubviewsWithIndentation:0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你可以看到如下的输出：
&lt;img src="http://localhost:2368/ru-he-jian-ce-ren-yi-viewde-subviewsde-guan-xi-shu/NO_Image" alt=""&gt;&lt;/p&gt;

&lt;p&gt;现在你可以看到mapView中所有藏在屏幕后面的view了，每一行输出前面的［］中的数字代表该行的view在树结构中的层次索引。&lt;/p&gt;

&lt;p&gt;你可以向下面这样获取到MKAnnotationContainerView&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;UIView *annotationContainerView = [[[[[[mapView subviews] objectAtIndex:0] subviews] objectAtIndex:0] subviews] objectAtIndex:1];  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，这种获取方式是不安全的，因为它取决于视图的特定顺序。所以你在使用以上方法获取对应视图的时候必须对它做一次测试：
if [subviews count] &gt; 0，或者使用像下面这样使用 NSClassFromString()：  &lt;/p&gt;

&lt;pre&gt;&lt;code class="language-ObjC"&gt;for (UIView *subview in subviews) {  
        if ([subview isKindOfClass:NSClassFromString(@"NameOfTheClass")]) {
            // We found the subview that we want
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后我想提示大家，苹果不希望开发者这样做，因为一些UIKit类的子视图是私有的，因此他们将会在将来更改这些类。所以以上方法只能在你没有其他方式的情况下谨慎的使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如有错误请指正，谢谢&lt;/strong&gt;&lt;/p&gt;</content:encoded></item><item><title>如何添加 Quick actions</title><description>&lt;p&gt;原文地址：&lt;a href="http://iostuts.io/2015/10/08/how-to-add-quick-actions/"&gt;http://iostuts.io/2015/10/08/how-to-add-quick-actions/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇教程介绍了Quick actions是如何工作的，如何创建Quick actions以及如何执行actions。此外，我们创建一个简单的app包含两个静态的Quick actions和一个动态的Quick actions。&lt;/p&gt;

&lt;p&gt;我们首先开始静态Quick actions创建。他们都被定义在Info.plist文件的特定键－－UIApplicationShortcutItems中。每一个子项是一个字典且至少要包含以下键：
1. &lt;strong&gt;UIApplicationShortcutItemType&lt;/strong&gt; ：作为UIApplicationShortcutItem的一部分发送给你的应用。可以依据不同的shortcut类型用于执行你的actions。 &lt;br&gt;
2. &lt;strong&gt;UIApplicationShortcutItemTitle&lt;/strong&gt;：展示在你的quick action菜单中的action标题。如果标题一行无法显示并且你没有指定子标题那么它将显示两行。可以使用本地化(localised).&lt;/p&gt;

&lt;p&gt;一些可选键：
1. &lt;strong&gt;UIApplicationShortcutItemSubtitle&lt;/strong&gt;: 用户展示你的actions的子标题的字符串。它将显示在你的quick actions标题的下方。可以本地化。 &lt;br&gt;
2. &lt;strong&gt;UIApplicationShortcutItemIconType&lt;/strong&gt;：定义内置图标类型的字符串，可选类型列表可以查询&lt;a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationShortcutIcon_Class/index.html#//apple_ref/c/tdef/UIApplicationShortcutIconType"&gt;这里&lt;/a&gt;； &lt;br&gt;
3. UIApplicationShortcutItemIconFile：一个指定Assets Catalog或者Bundle中的字符串。图像尺寸和设计的详细信息可以在&lt;a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/index.html#//apple_ref/doc/uid/TP40006556-CH66-SW1"&gt;&lt;/a&gt;&lt;/p&gt;</description><link>http://localhost:2368/ru-he-tian-jia-quick-actions/</link><guid isPermaLink="false">89d00f44-1343-4641-93c4-491116a4802b</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 18 Feb 2016 06:02:13 GMT</pubDate><content:encoded>&lt;p&gt;原文地址：&lt;a href="http://iostuts.io/2015/10/08/how-to-add-quick-actions/"&gt;http://iostuts.io/2015/10/08/how-to-add-quick-actions/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这篇教程介绍了Quick actions是如何工作的，如何创建Quick actions以及如何执行actions。此外，我们创建一个简单的app包含两个静态的Quick actions和一个动态的Quick actions。&lt;/p&gt;

&lt;p&gt;我们首先开始静态Quick actions创建。他们都被定义在Info.plist文件的特定键－－UIApplicationShortcutItems中。每一个子项是一个字典且至少要包含以下键：
1. &lt;strong&gt;UIApplicationShortcutItemType&lt;/strong&gt; ：作为UIApplicationShortcutItem的一部分发送给你的应用。可以依据不同的shortcut类型用于执行你的actions。 &lt;br&gt;
2. &lt;strong&gt;UIApplicationShortcutItemTitle&lt;/strong&gt;：展示在你的quick action菜单中的action标题。如果标题一行无法显示并且你没有指定子标题那么它将显示两行。可以使用本地化(localised).&lt;/p&gt;

&lt;p&gt;一些可选键：
1. &lt;strong&gt;UIApplicationShortcutItemSubtitle&lt;/strong&gt;: 用户展示你的actions的子标题的字符串。它将显示在你的quick actions标题的下方。可以本地化。 &lt;br&gt;
2. &lt;strong&gt;UIApplicationShortcutItemIconType&lt;/strong&gt;：定义内置图标类型的字符串，可选类型列表可以查询&lt;a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationShortcutIcon_Class/index.html#//apple_ref/c/tdef/UIApplicationShortcutIconType"&gt;这里&lt;/a&gt;； &lt;br&gt;
3. UIApplicationShortcutItemIconFile：一个指定Assets Catalog或者Bundle中的字符串。图像尺寸和设计的详细信息可以在&lt;a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/index.html#//apple_ref/doc/uid/TP40006556-CH66-SW1"&gt;这里&lt;/a&gt;找到如果指定了此键，则系统会忽略&lt;strong&gt;UIApplicationShortcutItemIconType&lt;/strong&gt; &lt;br&gt;
4. &lt;strong&gt;UIApplicationShortcutItemUserInfo&lt;/strong&gt;：一个字典，包含你想要解析的其他信息。&lt;/p&gt;

&lt;p&gt;等不及向你展示它是如何工作的了。&lt;/p&gt;

&lt;p&gt;我们需要创建一个Single View应用(File -&gt; New -&gt; Project).&lt;/p&gt;

&lt;p&gt;接着，打开Info.Plist文件并拷贝黏贴以下内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;key&amp;gt;UIApplicationShortcutItems&amp;lt;/key&amp;gt;  
&amp;lt;array&amp;gt;  
  &amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;UIApplicationShortcutItemIconType&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;UIApplicationShortcutIconTypeSearch&amp;lt;/string&amp;gt;   
    &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;SHORTCUT_TITLE_SEARCH&amp;lt;/string
    &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key
    &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER).Search&amp;lt;/string&amp;gt;
  &amp;lt;/dict&amp;gt;
  &amp;lt;dict&amp;gt;
    &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
    &amp;lt;string&amp;gt;SHORTCUT_TITLE_FAVORITES&amp;lt;/string
    &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key
    &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER).Favorites&amp;lt;/string&amp;gt;
  &amp;lt;/dict&amp;gt;
&amp;lt;/array&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你没有iPhone6s和6splus,那么可以用&lt;a href="https://github.com/DeskConnect/SBShortcutMenuSimulator"&gt;tweak&lt;/a&gt;在模拟器上测试。&lt;/p&gt;

&lt;p&gt;Build你的项目并试着3D touch你的app图标，它将向你展示一个菜单，十分的简单且很好，难道不是吗？ &lt;br&gt;
&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_1.png" alt="shortcuts_1.png"&gt;&lt;/p&gt;

&lt;p&gt;你可能已经注意到了两个问题：
1. 标题折行了。 &lt;br&gt;
2. 当你点击actions，它只是启动了app，并没有做任何的操作。&lt;/p&gt;

&lt;p&gt;让我们来完成余下的任务！&lt;/p&gt;

&lt;p&gt;我们的下一个挑战是如何执行这些actions。我们要时刻记得这有两种不同情况。
1. app处于关闭状态，用户通过quick action shorcut来打开应用。&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;将会被调用。参数launchingOptions字典中键名UIApplicationLaunchOptionsShortcutItemKey对应的value是UIApplicationShortcutItem对象。 &lt;br&gt;
2. app之前被打开过，此时处于挂起状态，用户通过shortcut继续使用。这种情况下应用将被唤醒，执行：&lt;code&gt;application:performActionForShortcutItem:completionHandler:&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;首先，我们创建一个私有方法，用来执行shortcut items。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;private func handleShortcutItem(shortcutItem: UIApplicationShortcutItem) {  
  if let rootViewController = window?.rootViewController {
    rootViewController.dismissViewControllerAnimated(false, completion: nil)
    let alertController = UIAlertController(title: "", message: shortcutItem.localizedTitle, preferredStyle: .Alert)
    alertController.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
    rootViewController.presentViewController(alertController, animated: true, completion: nil)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着，我们添加当app通过quick action返回前台的时候获取shortcut item的逻辑，黏贴以下代码到&lt;code&gt;application:didFinishLaunchingWithOptions:&lt;/code&gt;中。请不要忘记检测你的iOS系统版本，如果你的应用支持iOS8，app将会crash。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;if let shortcutItem = launchOptions?[UIApplicationLaunchOptionsShortcutItemKey] as? UIApplicationShortcutItem {  
  handleShortcutItem(shortcutItem)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后是声明：&lt;code&gt;application:performActionForShortcutItem:completionHandler:&lt;/code&gt;,该方法执行quick action，前提是app没有退出。将以下代码黏贴到AppDelegate中。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;func application(application: UIApplication, performActionForShortcutItem shortcutItem: UIApplicationShortcutItem, completionHandler: (Bool) -&amp;gt; Void) {  
  handleShortcutItem(shortcutItem)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新运行app并按压icon图标。你会发现当你使用quick action时，将会弹出alert并附带action 标题。&lt;/p&gt;

&lt;p&gt;在实际应用中，你应该是希望不同的shortcut item执行不同的actions。前面已经述说了，&lt;strong&gt;UIApplicationShortcutItemType是用来标记actions类型的&lt;/strong&gt;。让我们继续吧！&lt;/p&gt;

&lt;p&gt;将以下代码黏贴到AppDelegate的声明中：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;enum DGShortcutItemType: String {  
    case Search
    case Favorites

    init?(shortcutItem: UIApplicationShortcutItem) {
        guard let last = shortcutItem.type.componentsSeparatedByString(".").last else { return nil }
        self.init(rawValue: last)
    }

    var type: String {
        return NSBundle.mainBundle().bundleIdentifier! + ".\(self.rawValue)"
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们这里做的十分简单。每一个shortcut item包含一个类型，在示例中是：
* &lt;code&gt;$(PRODUCT_BUNDLE_IDENTIFIER).Favorites&lt;/code&gt;
* &lt;code&gt;$(PRODUCT_BUNDLE_IDENTIFIER).Search&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我们创建一个enumeration 用来解析这些值，可以使用比较简洁的写法：.Search 或者.Favorites&lt;/p&gt;

&lt;p&gt;现在用以下代码替换我们刚刚声明的handleShortcutItem方法&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;private func handleShortcutItem(shortcutItem: UIApplicationShortcutItem) {  
        if let rootViewController = window?.rootViewController, let shortcutItemType = DGShortcutItemType(shortcutItem: shortcutItem) {
            rootViewController.dismissViewControllerAnimated(false, completion: nil)
            let alertController = UIAlertController(title: "", message: "", preferredStyle: .Alert)

            switch shortcutItemType {
            case .Search:
                alertController.message = "It's time to search"
                break
            case .Favorites:
                alertController.message = "Show me my favorites"
                break
            }

            alertController.addAction(UIAlertAction(title: "OK", style: .Default, handler: nil))
            rootViewController.presentViewController(alertController, animated: true, completion: nil)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我门已经做了以下事情：
1.  我么在if控制语句内添加了&lt;code&gt;let shortcutItemType = DGShortcutItemType(shortcutItem: shortcutItem)&lt;/code&gt; 来确保这些值不是空的。如果我们添加一个新的shortcut则它可能为空，但是不会向enum添加新值。 &lt;br&gt;
2.  添加转换语句， 使每一个shortcut item类型能有不同的action&lt;/p&gt;

&lt;p&gt;运行项目并测试。现在每一个shortcut应该可以展示不同的alert了。&lt;/p&gt;

&lt;p&gt;Hm. 但是有一个地方肯定是错误的，我不希望是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_3.png" alt="shortcuts_3.png"&gt;&lt;/p&gt;

&lt;p&gt;这些shortcut 没有对应的图片，看起来不如Search shortcut那么美观。我想改进它。&lt;/p&gt;

&lt;p&gt;下载这些文件（&lt;a href="https://drive.google.com/file/d/0B16pTxwnU1H4VnZzbDF0Y19aRkE/view?usp=sharing"&gt;this file&lt;/a&gt;），并提取其中的图片放到Images.xcassets.&lt;/p&gt;

&lt;p&gt;打开Info.plist源码，并在Favorites Item 中添加如下两行。&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-HTML"&gt;&amp;lt;key&amp;gt;UIApplicationShortcutItemIconFile&amp;lt;/key&amp;gt;  
&amp;lt;string&amp;gt;ShortcutIconFavorites&amp;lt;/string&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有UIApplicationShortcutItems项应该是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-HTML"&gt; &amp;lt;key&amp;gt;UIApplicationShortcutItems&amp;lt;/key&amp;gt;
    &amp;lt;array&amp;gt;
        &amp;lt;dict&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemIconType&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;UIApplicationShortcutIconTypeSearch&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;SHORTCUT_TITLE_SEARCH&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER).Search&amp;lt;/string&amp;gt;
        &amp;lt;/dict&amp;gt;
        &amp;lt;dict&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemTitle&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;SHORTCUT_TITLE_FAVORITES&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemType&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;$(PRODUCT_BUNDLE_IDENTIFIER).Favorites&amp;lt;/string&amp;gt;
            &amp;lt;key&amp;gt;UIApplicationShortcutItemIconFile&amp;lt;/key&amp;gt;
            &amp;lt;string&amp;gt;ShortcutIconFavorites&amp;lt;/string&amp;gt;
        &amp;lt;/dict&amp;gt;
    &amp;lt;/array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行项目，现在当你3D touch 你的app icon时，你可以看到这样：
&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_4-1.png" alt="shortcuts_4-1.png"&gt;&lt;/p&gt;

&lt;p&gt;现在它看起来要好的多，我们已经学习了在quick action shortcuts中如何使用自定义assets。&lt;/p&gt;

&lt;p&gt;现在让我们来试着做一个动态的shortcut，从iOS9开始，UIApplication类有一个public变量&lt;code&gt;public var shortcutItems: [UIApplicationShortcutItem]?&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;注册一个shortcuts 在home屏展示， 或者检索已经注册的shortcuts.&lt;/p&gt;

&lt;p&gt;这正是我们要使用的。我们将创建一个接口来允许我们输入数据并更新/删除当前的shortcut。&lt;/p&gt;

&lt;p&gt;打开viewcontroller.swift文件，并替换所有代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;import UIKit

extension UIApplicationShortcutIconType {  
    var toString: String {
        switch self {
        case .Compose: return "Compose"
        case .Play: return "Play"
        case .Pause: return "Pause"
        case .Add: return "Add"
        case .Location: return "Location"
        case .Search: return "Search"
        case .Share: return "Share"
        }
    }

    init?(string: String) {
        switch string {
        case "Compose": self.init(rawValue: UIApplicationShortcutIconType.Compose.rawValue)
        case "Play": self.init(rawValue: UIApplicationShortcutIconType.Play.rawValue)
        case "Pause": self.init(rawValue: UIApplicationShortcutIconType.Pause.rawValue)
        case "Add": self.init(rawValue: UIApplicationShortcutIconType.Add.rawValue)
        case "Location": self.init(rawValue: UIApplicationShortcutIconType.Location.rawValue)
        case "Search": self.init(rawValue: UIApplicationShortcutIconType.Search.rawValue)
        case "Share": self.init(rawValue: UIApplicationShortcutIconType.Share.rawValue)
        default: return nil
        }
    }

    static var allTypesToStrings: [String] {
        return [UIApplicationShortcutIconType.Compose.toString, UIApplicationShortcutIconType.Play.toString, UIApplicationShortcutIconType.Pause.toString, UIApplicationShortcutIconType.Add.toString, UIApplicationShortcutIconType.Location.toString, UIApplicationShortcutIconType.Search.toString, UIApplicationShortcutIconType.Share.toString]
    }
}

class ViewController: UIViewController {

    // MARK: -
    // MARK: Vars

    private let titleTextField = UITextField()
    private let subtitleTextField = UITextField()
    private var iconTypeSegmentedControl = UISegmentedControl(items: UIApplicationShortcutIconType.allTypesToStrings)
    private let updateButton = UIButton(type: .System)

    // MARK: -

    override func loadView() {
        super.loadView()
        titleTextField.placeholder = "Title"
        titleTextField.delegate = self
        view.addSubview(titleTextField)

        subtitleTextField.placeholder = "Subtitle"
        subtitleTextField.delegate = self
        view.addSubview(subtitleTextField);

        updateButton.setTitle("Update shortcut", forState: .Normal)
        updateButton.addTarget(self, action: Selector("updateDynamicAction"), forControlEvents: .TouchUpInside)
        view.addSubview(updateButton)

        iconTypeSegmentedControl.selectedSegmentIndex = 0
        view.addSubview(iconTypeSegmentedControl)

        view.addGestureRecognizer(UITapGestureRecognizer(target: self, action: "viewTapped"))
    }

    // MARK: -
    // MARK: Methods

    func viewTapped() {
        view.endEditing(true)
    }

    func updateDynamicAction() {
        guard let title = titleTextField.text else {
            UIApplication.sharedApplication().shortcutItems = nil
            return
        }

        let type = NSBundle.mainBundle().bundleIdentifier! + ".Dynamic"
        let shortcutIconType = UIApplicationShortcutIconType(string: iconTypeSegmentedControl.titleForSegmentAtIndex(iconTypeSegmentedControl.selectedSegmentIndex)!)!
        let icon = UIApplicationShortcutIcon(type: shortcutIconType)

        let dynamicShortcut = UIApplicationShortcutItem(type: type, localizedTitle: title, localizedSubtitle: subtitleTextField.text, icon: icon, userInfo: nil)
        UIApplication.sharedApplication().shortcutItems = [dynamicShortcut]
    }

    // MARK: -
    // MARK: Layout

    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews()

        let width = view.bounds.width

        let horizontalMargin: CGFloat = 20.0
        let elementHeight: CGFloat = 40.0
        let verticalSpacing: CGFloat = 20.0

        titleTextField.frame = CGRect(x: horizontalMargin, y: 50.0, width: width - 2 * horizontalMargin, height: elementHeight)
        subtitleTextField.frame = CGRectOffset(titleTextField.frame, 0.0, elementHeight + verticalSpacing)
        iconTypeSegmentedControl.frame = CGRectOffset(subtitleTextField.frame, 0.0, elementHeight + verticalSpacing)
        updateButton.frame = CGRectOffset(iconTypeSegmentedControl.frame, 0.0, elementHeight + verticalSpacing)
    }

}

// MARK: -
// MARK: UITextField Delegate

extension ViewController: UITextFieldDelegate {

    func textFieldShouldReturn(textField: UITextField) -&amp;gt; Bool {
        if textField == titleTextField {
            subtitleTextField.becomeFirstResponder()
        } else if textField == subtitleTextField {
            subtitleTextField.resignFirstResponder()
        }

        return true
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些代码看起来很多，但是它十分基础并且不需要解释。&lt;/p&gt;

&lt;p&gt;运行项目，你会看到简单的界面：
&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_5.png" alt="shortcuts_5.png"&gt;&lt;/p&gt;

&lt;p&gt;点击：“Update shortcut” 添加一些数据。 试着3Dtouch你的app，你将看到如下情景：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/shortcuts_6-1.png" alt="shortcuts_6-1.png"&gt;&lt;/p&gt;

&lt;p&gt;有一个游戏，尝试改变值，按“更新的快捷方式”，它将改变。如果你离开了标题标签，并要求更新，那么该快捷方式将被删除。我们可以随时添加、删除、更改快捷方式。&lt;/p&gt;

&lt;p&gt;还有一件事情没有做了，就是当我们通过Dynamic shortcut来打开app的时候没有做任何事情。现在我们要添加alets，来展示如何做到这一点。&lt;/p&gt;

&lt;p&gt;以下时我们需要做的：
添加 case Dynamic 到 DGShortcutItemType enumeration 来支持这种类型。
在handleShortcutItem方法的switch语句中添加如下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-Swift"&gt;case .Dynamic:  
    alertController.message = "Dynamic shortcut works!"
    break
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在updateDynamicAction方法改变：
NSBundle.mainBundle().bundleIdentifier! + ".Dynamic" 修改为DGShortcutItemType.Dynamic.type&lt;/p&gt;

&lt;p&gt;运行项目并测试3D touch。 当你打开app， 它将展示每一个shortcuts指定的消息。&lt;/p&gt;

&lt;p&gt;我想我们已经完成了Quick Actions 主要逻辑。本教程源码在这里（&lt;a href="https://github.com/gontovnik/DGQuickActionsTutorial"&gt;here&lt;/a&gt;）可以下载。&lt;/p&gt;

&lt;p&gt;希望大家喜欢，并留下你们的观点和建议。再见！&lt;/p&gt;</content:encoded></item><item><title>UIPresentationController</title><description>&lt;p&gt;&lt;strong&gt;UIPresentationController&lt;/strong&gt;是在iOS8.0后出现，用来提供高级视图切换功能, 使管理present ViewController的过程变得简单。&lt;/p&gt;

&lt;h4 id=""&gt;&lt;strong&gt;重要属性及方法&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// presentation(演示)起点的ViewController(只读属性)
   public var presentingViewController: UIViewController { get }

// 要展示的ViewController(只读属性)
   public var presentedViewController: UIViewController { get }

// 演示风格
   public var presentationStyle: UIModalPresentationStyle { get }

// presented和presenting ViewController的祖先视图。
   public var containerView: UIView? { get }

/* presentation过程中的动画视图，必须是presentedViewController.view的祖先视图，或者是
  presentedViewController.view本身.(默认值：presentedViewController.view本身)*/
   public func presentedView() -&amp;gt;&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/uipresentationcontroller/</link><guid isPermaLink="false">c6f29087-b69f-4708-8afe-0c4a576263ef</guid><dc:creator>ioneway</dc:creator><pubDate>Thu, 18 Feb 2016 05:20:52 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;UIPresentationController&lt;/strong&gt;是在iOS8.0后出现，用来提供高级视图切换功能, 使管理present ViewController的过程变得简单。&lt;/p&gt;

&lt;h4 id=""&gt;&lt;strong&gt;重要属性及方法&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// presentation(演示)起点的ViewController(只读属性)
   public var presentingViewController: UIViewController { get }

// 要展示的ViewController(只读属性)
   public var presentedViewController: UIViewController { get }

// 演示风格
   public var presentationStyle: UIModalPresentationStyle { get }

// presented和presenting ViewController的祖先视图。
   public var containerView: UIView? { get }

/* presentation过程中的动画视图，必须是presentedViewController.view的祖先视图，或者是
  presentedViewController.view本身.(默认值：presentedViewController.view本身)*/
   public func presentedView() -&amp;gt; UIView?

// 展示动画开始时调用
   public func presentationTransitionWillBegin()
// 展示动画结束后调用
   public func presentationTransitionDidEnd(completed: Bool)
// 消失动画开始时调用
   public func dismissalTransitionWillBegin()
// 消失动画结束时调用
   public func dismissalTransitionDidEnd(completed: Bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在iPad的设置页面，可以通过popOver弹出一个UIViewController，这个弹出的可以和用户交互的Controller叫做PresentedViewController，而后面那个被部分遮挡的UIViewController叫做PresentingViewController。&lt;br&gt;
如图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/presentation.png" alt="presentation"&gt;&lt;/p&gt;</content:encoded></item><item><title>CGRectInset 和 CGRectOffset</title><description>&lt;h3 id="cgrectinset"&gt;CGRectInset&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; func CGRectInset(_ rect: CGRect, _ dx: CGFloat, _ dy: CGFloat) -&amp;gt; CGRect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回一个矩形，这个矩形以原矩形的中心点为中心，比原矩形大或者小。&lt;/p&gt;

&lt;p&gt;参数：&lt;br&gt;
rect:原矩形. &lt;br&gt;
dx:x坐标值用来调整原矩形。创建一个inset矩形，指定正值则比原矩形宽，指定负值则比原矩形窄. &lt;br&gt;
dy:y坐标值用来调整原矩形。创建一个inset矩形，指定正值则比原矩形高，指定负值则比原矩形短.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)testCGRectInset  
{  
    UIView *view1=[[UIView alloc]initWithFrame:CGRectMake(120, 120, 200, 200)];  
    [view1 setBackgroundColor:[UIColor grayColor]];//view1 设置为灰色  
    [self.view addSubview:&lt;/code&gt;&lt;/pre&gt;</description><link>http://localhost:2368/cgrectinset-he-cgrectoffset/</link><guid isPermaLink="false">efaa1ad3-946c-4240-8645-0318b6ec2d00</guid><dc:creator>ioneway</dc:creator><pubDate>Wed, 17 Feb 2016 08:32:50 GMT</pubDate><content:encoded>&lt;h3 id="cgrectinset"&gt;CGRectInset&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; func CGRectInset(_ rect: CGRect, _ dx: CGFloat, _ dy: CGFloat) -&amp;gt; CGRect
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回一个矩形，这个矩形以原矩形的中心点为中心，比原矩形大或者小。&lt;/p&gt;

&lt;p&gt;参数：&lt;br&gt;
rect:原矩形. &lt;br&gt;
dx:x坐标值用来调整原矩形。创建一个inset矩形，指定正值则比原矩形宽，指定负值则比原矩形窄. &lt;br&gt;
dy:y坐标值用来调整原矩形。创建一个inset矩形，指定正值则比原矩形高，指定负值则比原矩形短.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)testCGRectInset  
{  
    UIView *view1=[[UIView alloc]initWithFrame:CGRectMake(120, 120, 200, 200)];  
    [view1 setBackgroundColor:[UIColor grayColor]];//view1 设置为灰色  
    [self.view addSubview:view1];  

    //根据view1的大小变换后创建view2;  
    CGRect view2Rect=CGRectInset(view1.frame, 20, 20);  
    UIView *view2=[[UIView alloc]initWithFrame:view2Rect];  
    [view2 setBackgroundColor:[UIColor blueColor]];//view2 设置为蓝色  
    [self.view addSubview:view2];  


}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码：产生的效果如图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/20150731115650388.png" alt="CGRectInset"&gt;&lt;/p&gt;

&lt;h3 id="cgrectoffset"&gt;CGRectOffset&lt;/h3&gt;

&lt;p&gt;返回一个经过平移后的矩形。(与原矩形大小一致)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func CGRectOffset(_ rect: CGRect, _ dx: CGFloat, _ dy: CGFloat) -&amp;gt; CGRect  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数：&lt;br&gt;
rect: 原矩形 &lt;br&gt;
dx: 平移的x坐标 &lt;br&gt;
dy: 平移的y坐标&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-(void)testCGRectOffset  
{  
    UIView *view1=[[UIView alloc]initWithFrame:CGRectMake(120, 120, 200, 200)];  
    [view1 setBackgroundColor:[UIColor grayColor]];//view1 设置为灰色  
    [self.view addSubview:view1];  

    //根据view1的大小变换后创建view2;  
    CGRect view2Rect=CGRectOffset(view1.frame, 20, 20);  
    UIView *view2=[[UIView alloc]initWithFrame:view2Rect];  
    [view2 setBackgroundColor:[UIColor blueColor]];//view2 设置为蓝色  
    [self.view addSubview:view2];    
}  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
以上代码运行效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/20150731120023106.png" alt="CGRectOffset"&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt; CGRectInset主要是得到一个缩放了的矩形，而CGRectOffset是得到一个平移了的矩形。&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title>Hit-Testing in iOS</title><description>&lt;p&gt;&lt;code&gt;Hit-testing&lt;/code&gt;翻译为中文是"命中测试"，是确定touch-point是否在一个View内的过程,最终命中的View被称为&lt;code&gt;hit-test view&lt;/code&gt;。iOS使用hit-testing来确定那一个UIView是用户手指下最靠前的且能够接收touch事件的view。hit-testing通过&lt;code&gt;反向前序深度优先&lt;/code&gt;算法来便利视图的层次结构，从而实现上述功能。&lt;/p&gt;

&lt;p&gt;在解释hit-testing 如何工作前，我们先要了解下hit-testing是在什么时候执行的。以下图分解了一个手指从触摸屏幕到离开屏幕的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-touch-event-flow.png" alt="hit-test-touch-event-flow"&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，每次手指触碰屏幕都会触发hit-testing, 并且hit-testing在各个视图和gesture recognizer接收UIEvent 事件之前触发。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;不清楚是什么原因，hit-testing会连续执行多次。并且，hit-test view 的hit-testing也会执行多次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;hit-testing完成后，最前方且能够接收事件的view就会被确定为hit-test view。hit-test view与各个阶段(begin,move,end,cancel)的触摸事件序列的UITouch对象相关联。hit-test view确定后，开始接收touch事件序列。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;需要了解的是，手指被移动到了hit-test view外，而移动到了另一个view内时，hit-test视图依旧会&lt;code&gt;接收整个&lt;/code&gt;touch事件的序列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;</description><link>http://localhost:2368/hit-testing-in-ios/</link><guid isPermaLink="false">5dd1d295-69d5-4499-916a-32480d5dcb11</guid><dc:creator>ioneway</dc:creator><pubDate>Tue, 16 Feb 2016 06:29:52 GMT</pubDate><content:encoded>&lt;p&gt;&lt;code&gt;Hit-testing&lt;/code&gt;翻译为中文是"命中测试"，是确定touch-point是否在一个View内的过程,最终命中的View被称为&lt;code&gt;hit-test view&lt;/code&gt;。iOS使用hit-testing来确定那一个UIView是用户手指下最靠前的且能够接收touch事件的view。hit-testing通过&lt;code&gt;反向前序深度优先&lt;/code&gt;算法来便利视图的层次结构，从而实现上述功能。&lt;/p&gt;

&lt;p&gt;在解释hit-testing 如何工作前，我们先要了解下hit-testing是在什么时候执行的。以下图分解了一个手指从触摸屏幕到离开屏幕的过程。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-touch-event-flow.png" alt="hit-test-touch-event-flow"&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，每次手指触碰屏幕都会触发hit-testing, 并且hit-testing在各个视图和gesture recognizer接收UIEvent 事件之前触发。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;不清楚是什么原因，hit-testing会连续执行多次。并且，hit-test view 的hit-testing也会执行多次。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;hit-testing完成后，最前方且能够接收事件的view就会被确定为hit-test view。hit-test view与各个阶段(begin,move,end,cancel)的触摸事件序列的UITouch对象相关联。hit-test view确定后，开始接收touch事件序列。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意：&lt;/code&gt;需要了解的是，手指被移动到了hit-test view外，而移动到了另一个view内时，hit-test视图依旧会&lt;code&gt;接收整个&lt;/code&gt;touch事件的序列。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;“The touch object is associated with its hit-test view for its lifetime, even if the touch later moves outside the view.”&lt;br&gt;
  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;
  &lt;a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/event_delivery_responder_chain/event_delivery_responder_chain.html#//apple_ref/doc/uid/TP40009541-CH4-SW4"&gt;Event Handling Guide for iOS, iOS Developer Library&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如前所述，命中测试采用反向预定深度优先遍历（先访问根结点，然后遍历其子树由高到低的指标）。这种遍历可以减少遍历迭代次数，并在搜索到第一个包含touch-point的最深的子视图中停止搜索过程。这可能是因为一个视图总是在它的父视图之前渲染，而兄弟视图总是比在subviews具有较低索引的兄弟视图先渲染。这样，多个重叠的视图都包含一个touch-point时，在右子树的最深的视图是第一个被渲染的。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;“Visually, the content of a subview obscures all or part of the content of its parent view. Each superview stores its subviews in an ordered array and the order in that array also affects the visibility of each subview. If two sibling subviews overlap each other, the one that was added last (or was moved to the end of the subview array) appears on top of the other.”&lt;br&gt;
  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href="https://developer.apple.com/library/ios/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/WindowsandViews/WindowsandViews.html#//apple_ref/doc/uid/TP40009503-CH2-SW24"&gt;View Programming Guide for iOS, iOS Developer Library&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下图显示了一个视图层次树及其匹配的用户界面。从左到右树枝序列影响着subviews的数组顺序。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-view-hierarchy.png" alt="hit-test-view-hierarchy"&gt;&lt;/p&gt;

&lt;p&gt;图中可以看到，“VIewA”和“ViewB”和它们的子视图，“ViewA.2”和“View B.1”有重叠。但是“ViewB”在subViews中的索引值高于“ViewA”，“ViewB”和它的子视图会展现在“View A”和它的子视图之上。 因此，用户手指触摸 “View.b.1”与”View.A.2”重叠区域时，hit-testing返回“View.B.1”。&lt;/p&gt;

&lt;p&gt;通过应用深度优先反向前序遍历算法，各个视图的遍历路径如图：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-depth-first-traversal.png" alt="hit-test-depth-first-traversal"&gt;&lt;/p&gt;

&lt;p&gt;遍历算法先发送hitTest:withEvent: 到UIWindow，UIWindow是视图层次结构的根视图。此方法返回的值是包含了触摸点的最靠前面的视图。&lt;br&gt;&lt;/p&gt;

&lt;p&gt;下面的流程图说明了命中测试逻辑。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-flowchart.png" alt="hit-test-flowchart"&gt;&lt;/p&gt;

&lt;p&gt;以下代码是&lt;code&gt;hitTest:withEvent:&lt;/code&gt;可能的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    if ([self pointInside:point withEvent:event]) {
        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            if (hitTestView) {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法首先检查视图是否允许接收touch事件。如果一个View允许接收touch事件，则必须满足以下所有条件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;self.hidden == NO&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;self. self.userInteractionEnabled = YES&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.alpha &amp;gt; 0.1&lt;/code&gt;  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;pointInside:withEvent: == YES&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当视图View允许接收touch事件时，该方法就会反向枚举它的子视图，然后逐个发送&lt;code&gt;hitTest:withEvent:&lt;/code&gt;消息，直到有一个子视图返回了nil。第一个返回非nil值的子视图就是这些子视图中最靠前且在touch-point下的视图。如果所有视图都返回nil或者该视图没有子视图则函数返回self.&lt;/p&gt;

&lt;p&gt;如果视图View不允许接收touch事件，该方法返回nil,而不需要在反向枚举。因此，hit-testing并不需要访问视图层次树上的所有视图。&lt;/p&gt;

&lt;h4 id="hittestwithevent"&gt;hitTest:withEvent:运用场景&lt;/h4&gt;

&lt;p&gt;hitTest:withEvent:可以被覆盖，当所有触摸事件阶段的所有阶段的触摸事件想要被一个视图处理重定向到另外一个视图。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;*注意: *&lt;/em&gt;因为hit-test仅仅在触摸事件顺序的第一次触摸事件（UITouchPhaseBegan phase(阶段)的触摸事件）发送给他的接收者之前，覆盖hitTest:withEvent:来重定向事件将会重定向所有phase的触摸事件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;1.增加视图区域&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;覆盖&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法的一个用途就是，当一个视图的触摸区域应该大于他的边界的时候。例如下面的插图显示了一个大小为20*20的视图。这个大小对于处理附近的触摸来说太小了。因此，他的触摸区域可以通过覆盖&lt;code&gt;hitTest:withEvent:&lt;/code&gt;在每个方向增加10。&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-increase-touch-area.png" alt="hit-test-increase-touch-area"&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.isUserInteractionEnabled || self.isHidden || self.alpha &amp;lt;= 0.01) {
        return nil;
    }
    CGRect touchRect = CGRectInset(self.bounds, -10, -10);
    if (CGRectContainsPoint(touchRect, point)) {
        for (UIView *subview in [self.subviews reverseObjectEnumerator]) {
            CGPoint convertedPoint = [subview convertPoint:point fromView:self];
            UIView *hitTestView = [subview hitTest:convertedPoint withEvent:event];
            if (hitTestView) {
                return hitTestView;
            }
        }
        return self;
    }
    return nil;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;为了能够正确的调用&lt;code&gt;hit-test&lt;/code&gt;，父视图的边界应该包含子视图希望触摸的区域，或者他的&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法也应该被覆盖来包含期望的触摸区域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2.传递触摸事件给下面的视图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有的时候对于一个视图忽略触摸事件并传递给下面的视图是很重要的。例如，假设一个透明的视图覆盖在应用内所有视图的最上面。覆盖层有子视图应该相应触摸事件的一些控件和按钮。但是触摸覆盖层的其他区域应该传递给覆盖层下面的视图。为了完成这个行为，覆盖层需要覆盖hitTest:withEvent:方法来返回包含触摸点的子视图中的一个，然后其他情况返回nil，包括覆盖层包含触摸点的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *hitTestView = [super hitTest:point withEvent:event];
    if (hitTestView == self) {
        hitTestView = nil;
    }
    return hitTestView;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3.传递触摸事件给子视图&lt;/strong&gt;
一个不同的使用场景可能需要父视图重定向所有的触摸事件给他唯一的子视图。这个行为是有必要的当子视图部分占据他的父视图，但是子视图应该响应所有的触摸事件包括发生在父视图上的。例如，假设一个由一个父视图和一个&lt;code&gt;pagingEnabled&lt;/code&gt;设置为YES和&lt;code&gt;clipsToBounds&lt;/code&gt;设置为NO（为了实现传动带的效果）的&lt;code&gt;UIScrollView&lt;/code&gt;组成的图片浏览器：&lt;/p&gt;

&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/hit-test-pass-touches-to-subviews.png" alt="hit-test-pass-touches-to-subviews"&gt;&lt;/p&gt;

&lt;p&gt;为了使&lt;code&gt;UIScrollView&lt;/code&gt;响应不发生在自己边界内但是在父视图的边界内的触摸事件，父视图的&lt;code&gt;hitTest:withEvent:&lt;/code&gt;方法应该像下面这样重写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    UIView *hitTestView = [super hitTest:point withEvent:event];
    if (hitTestView) {
        hitTestView = self.scrollView;
    }
    return hitTestView;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;如有问题请指正, 谢谢。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;另外一篇是一位大神的翻译，翻译了一半的时候才发现的，索性后半部分就直接粘贴了。&lt;br&gt;
大神翻译：&lt;a href="http://joywii.github.io/blog/2015/03/17/ioszhong-de-hit-testing/"&gt;http://joywii.github.io/blog/2015/03/17/ioszhong-de-hit-testing/&lt;/a&gt;&lt;br&gt;
原文地址：&lt;a href="http://smnh.me/hit-testing-in-ios/"&gt;http://smnh.me/hit-testing-in-ios/&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title>GitHubPages＋Ghost搭建博客</title><description>&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/headImg-3.jpg" alt="The Ghost Logo"&gt;&lt;/p&gt;

&lt;p&gt;对IT技术的学习也有不短的时间了。经常观看大神们的博客，对于他们博客不仅仅内容精彩，而且主题也很大气高端，所以也希望自己能有一个这样的博客。&lt;/p&gt;

&lt;p&gt;首先就是要选择博客平台，经过一番对比，最终选&lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;，因为其免费且专业，并且还有以下优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简易的配置，轻量级别系统，不需要数据库&lt;/li&gt;
&lt;li&gt;支持标记语言，如Markdown&lt;/li&gt;
&lt;li&gt;使用GitHub托管服务，免费300MB空间&lt;/li&gt;
&lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;li&gt;支持CDN，提升访问速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然GitHub Pages也有一些缺陷：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt; 模板系统，属于静态页面&lt;/li&gt;
&lt;li&gt;基于Git操作，需要有一定的动手能力&lt;/li&gt;
&lt;li&gt;动态性不好，没有评论系统，不过可以自己配置&lt;a href="https://disqus.com"&gt;Disqus&lt;/a&gt; 扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于GitHub Pages对Jekyll无缝支持。可是我在Jekyll主题市场里找了许久，没能找到我想要的那种看上去简洁，高端，并且适合程序员写技术博客的主题。于是就去借鉴大神们的选择，发现OneV‘cat的博客主题:&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;正是我所想要的那种。&lt;/p&gt;

&lt;p&gt;OneVcat中使用的博客程序是&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;是一种轻量级的动态博客，&lt;/p&gt;</description><link>http://localhost:2368/githubpages-ghostda-jian-bo-ke/</link><guid isPermaLink="false">cc9b5426-38d8-41e8-8022-8b289e963f66</guid><dc:creator>ioneway</dc:creator><pubDate>Sat, 30 Jan 2016 09:28:09 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/02/headImg-3.jpg" alt="The Ghost Logo"&gt;&lt;/p&gt;

&lt;p&gt;对IT技术的学习也有不短的时间了。经常观看大神们的博客，对于他们博客不仅仅内容精彩，而且主题也很大气高端，所以也希望自己能有一个这样的博客。&lt;/p&gt;

&lt;p&gt;首先就是要选择博客平台，经过一番对比，最终选&lt;a href="https://pages.github.com"&gt;GitHub Pages&lt;/a&gt;，因为其免费且专业，并且还有以下优点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;简易的配置，轻量级别系统，不需要数据库&lt;/li&gt;
&lt;li&gt;支持标记语言，如Markdown&lt;/li&gt;
&lt;li&gt;使用GitHub托管服务，免费300MB空间&lt;/li&gt;
&lt;li&gt;可以绑定自己的域名&lt;/li&gt;
&lt;li&gt;支持CDN，提升访问速度&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然GitHub Pages也有一些缺陷：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt; 模板系统，属于静态页面&lt;/li&gt;
&lt;li&gt;基于Git操作，需要有一定的动手能力&lt;/li&gt;
&lt;li&gt;动态性不好，没有评论系统，不过可以自己配置&lt;a href="https://disqus.com"&gt;Disqus&lt;/a&gt; 扩展。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由于GitHub Pages对Jekyll无缝支持。可是我在Jekyll主题市场里找了许久，没能找到我想要的那种看上去简洁，高端，并且适合程序员写技术博客的主题。于是就去借鉴大神们的选择，发现OneV‘cat的博客主题:&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;正是我所想要的那种。&lt;/p&gt;

&lt;p&gt;OneVcat中使用的博客程序是&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;是一种轻量级的动态博客，有一个管理后台，可以直接写作和管理博客。本质上和WordPress是相通的，只是 Ghost 搭建在 Node.js 环境上，轻量，快速，简洁。&lt;/p&gt;

&lt;p&gt;所以我最终选择了&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt;，因为其高颜值和强大的后台管理,另外还有一个原因就是它还有&lt;a href="http://www.ghostchina.com"&gt;中文版Ghost&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 技术栈简要解析
把 &lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 的结构厘清，其实蛮简单，特别是使用官方已经编译好的 &lt;a href="https://blog.ghost.org"&gt;Ghost&lt;/a&gt; 压缩包解压后进行二次开发的话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ghost 的页面使用的是 &lt;code&gt;Handlebars.js&lt;/code&gt; 前端模板引擎，页面总数在 10 个左右。页面采用&lt;code&gt;引入/调用&lt;/code&gt;方式，就是把常规的 HTML 结构，譬如 &lt;code&gt;meta&lt;/code&gt; 头信息、&lt;code&gt;header&lt;/code&gt;、&lt;code&gt;footer&lt;/code&gt; 等常用且可以复用的 HTML 页面结构，给独立成一个个模板文件，而在其他诸如&lt;code&gt;单篇博文页、博主个人主页&lt;/code&gt;等页面模板文件内，引用上面的独立模板文件。譬如在单篇博文页内引入 meta 头信息模板文件，就可以达到一处编写,处处调用的类似&lt;code&gt;变量调用/引入&lt;/code&gt;的概念。&lt;strong&gt;前端模板引擎的出现，给前端开发人员缩短开发周期起到了不可或缺的作用&lt;/strong&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于GitHub Pages只支持静态博客，而Ghost却是动态的。所谓动态博客，需要服务器来支持数据输出。而静态页面，就是诸如&lt;code&gt;HTML&lt;/code&gt;,&lt;code&gt;XML&lt;/code&gt;等标记语言写好结构，用&lt;code&gt;css&lt;/code&gt;描述好表现样式，用&lt;code&gt;JavaScript&lt;/code&gt;写好了交互逻辑的，理论上不再接受后端服务器数据输出而动态修改的页面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;简而言之，静态页面是死的，动态页面是活的。&lt;/em&gt;&lt;/strong&gt;对于Github Pages这样仅仅支持静态网站/页面的托管服务而言，怎么搞定Ghost的托管呢？&lt;/p&gt;

&lt;h3 id="buster"&gt;&lt;strong&gt;开源项目&lt;code&gt;Buster&lt;/code&gt;&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Buster是&lt;code&gt;Python&lt;/code&gt;语言写的一个&lt;strong&gt;文件路径遍历器&lt;/strong&gt;。通过调用&lt;code&gt;Wget&lt;/code&gt;把Ghost中用到的图片，字体，CSS，javaScript等静态资源统一复制到一个新的文件夹(同时此文件夹可以作为Github Pages的仓库)，然后相应地修改HTML文件内引用的静态文件的路径，使之最终生效。Buster由Misiur提供：&lt;a href="https://github.com/Misiur/buster"&gt;https://github.com/Misiur/buster&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=""&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;1, &lt;a href="https://nodejs.org/en/download/releases"&gt;Node.js&lt;/a&gt;：Ghost依赖Node.js。 建议安装v0.10.26版本。&lt;/p&gt;
  
  &lt;p&gt;2, &lt;a href="http://git-scm.com/download"&gt;Git&lt;/a&gt;: 用于克隆项目到本地，部署、提交项目到 Github。Mac OSX 自带。&lt;/p&gt;
  
  &lt;p&gt;3, &lt;a href="https://www.python.org/downloads/"&gt;Python&lt;/a&gt;：用于执行Buster工具，Mac OSX自带。&lt;/p&gt;
  
  &lt;p&gt;4, &lt;a href="https://github.com/pypa/pip"&gt;pip&lt;/a&gt;: Python包管理工具，用于安装Buster工具。&lt;/p&gt;
  
  &lt;p&gt;5, &lt;a href="https://github.com/Misiur/buster"&gt;Buster&lt;/a&gt;: 用于将Ghost动态页面转换为静态页面。&lt;/p&gt;
  
  &lt;p&gt;6, &lt;a href="https://github.com/diancloud/Ghost"&gt;Ghost中文版&lt;/a&gt;：建议安装中文版，因为中文版已经包含了所有需要的插件。&lt;/p&gt;
  
  &lt;p&gt;7, &lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;：一款简洁高端大气的ghost博客主题。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=""&gt;&lt;strong&gt;具体步骤&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1，搭建环境&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装node.js，建议v0.10.6版本&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;brew update  
brew install nvm //安装nvm  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并在(~/.bashrc, ~/.profile, or ~/.zshrc)中添加如下内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#For NVM
export NVM_DIR=~/.nvm  
source $(brew --prefix nvm)/nvm.sh  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用nvm安装node.js &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nvm install v0.10.6  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入用户Documents目录,并新建文件夹：GithubPages_ZH.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class="language-Shell"&gt;cd ~/Documents &amp;amp;&amp;amp; mkdir GithubPages_ZH  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH目录，并下载&lt;a href="https://github.com/diancloud/Ghost"&gt;Ghost中文版&lt;/a&gt;，并将其命名为Ghost。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd GithubPages_ZH  
git clone https://github.com/diancloud/Ghost.git  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH/Ghost/content/themes/, 然后下载&lt;a href="https://github.com/onevcat/vno"&gt;vno&lt;/a&gt;主题.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd Ghost/content/themes/  
git clone https://github.com/onevcat/vno.git  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;进入GithubPages_ZH/Ghost 启动Ghost服务&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;nvm use default 0.10.6  
npm start  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;浏览器打开:&lt;a href="http://localhost:2368/ghost"&gt;http://localhost:2368/ghost&lt;/a&gt;进入后台管理页面。注册一个管理员帐号，并记住帐号密码。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置主题
点击左侧栏“全局设置”按钮，进入设置页面，下滑到最下方，主题：选择vno主题，并保存。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装pip:Python包管理工具&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo easy_install pip  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;安装Buster: 执行以下命令&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;pip install git+https://github.com/Misiur/buster  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登陆Github 创建仓库，仓库名称&lt;code&gt;必须是&lt;/code&gt;：&lt;code&gt;[your－username].github.io&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;终端执行以下命令：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd ~/GithubPages_ZH  
buster setup -gh-repo=\  
"https://github.com/&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git"
//这里会要求输入github帐号密码。
buster generate //产生静态文件，此时会在当前文件夹下产生static文件夹。  
buster deploy  //发布  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在static文件夹下添加文件：.gitignore文件，用于在提交github时忽略部分文件。在.gitignore中添加如下内容：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# vim ~tmp files
*.swp
*.un~

# ignore bourbon install so that it is the latest build
# for developers that need it
assets/scss/bourbon/*

# ignore the sass-cache/
.sass-cache/*
**/.sass-cache/*

### OSX ###
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear on external disk
.Spotlight-V100
.Trashes

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder  
Temporary Items  
.apdisk
config.codekit  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;你需要根据自己的实际情况对主题中各个按钮的点击链接以及图片进行设置，具体请参考链接：&lt;a href="https://github.com/onevcat/vno"&gt;https://github.com/onevcat/vno&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，Ghost博客搭建完成。之后每次跟新博客时：需要点击编辑窗口右上方的更新按钮，然后终端执行以下命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//在GithubPages_ZH下执行
//不需要再次执行Buster setup 命令
buster generate  
buster deploy  //发布  
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id="ghost"&gt;Ghost 相关资源推荐&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;各种 Ghost 主题：&lt;a href="http://www.allghostthemes.com"&gt;http://www.allghostthemes.com&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;官方主题市场：&lt;a href="http://marketplace.ghost.org"&gt;http://marketplace.ghost.org&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id="ghost"&gt;&lt;strong&gt;Ghost高级设置&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;添加评论系统&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;注册&lt;a href="http://duoshuo.com"&gt;多说&lt;/a&gt;帐号,点击“安装”按钮并填写相关设置;  &lt;/li&gt;
&lt;li&gt;复制稳定版通用代码，黏贴在：&lt;code&gt;Ghost/content/themes/casper/post.hbs&lt;/code&gt;模板文件的 ｀｀&lt;code&gt;{{/post}}&lt;/code&gt; 标签前，并保存。 &lt;br&gt;
如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-22-43.png" alt="duoshuo_code"&gt;


&lt;blockquote&gt;
  &lt;p&gt;&lt;code&gt;注意&lt;/code&gt;将其中中文字符分别替换为：&lt;code&gt;{{id}}&lt;/code&gt;， &lt;code&gt;{{title}}&lt;/code&gt;，&lt;code&gt;ioneway.github.io{{url}}&lt;/code&gt;. 其中&lt;code&gt;ioneway.github.io&lt;/code&gt;替换为你的域名。&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;
  &lt;/ol&gt;
  最终粘贴的代码如下：&lt;p&gt;&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;&amp;lt;!-- 多说评论框 start --&amp;gt;  
    &amp;lt;div class="ds-thread" data-thread-key="{{id}}" data-title="{{title}}" data-url="ioneway.github.io{{url}}"&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;!-- 多说评论框 end --&amp;gt;  
&amp;lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&amp;gt;  
&amp;lt;script type="text/javascript"&amp;gt;  
var duoshuoQuery = {short_name:"abcbytr"};  
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    &amp;lt;/script&amp;gt;
&amp;lt;!-- 多说公共JS代码 end --&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;


 登陆多说，进入设置页面，基本设置。正确填写以下两项：首页网址：&lt;a href="http://ioneway.github.io"&gt;http://ioneway.github.io&lt;/a&gt;
，首选域名：选择最后一项：“将网址显示为ioneway.github.io”。保存。

如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-41-14.png" alt="duoshuo_setting"&gt;

&lt;br&gt;&lt;br&gt;

**2，添加 CNZZ 统计**

1， 注册[CNZZ](http://www.cnzz.com)  
2， 登陆[CNZZ](http://www.cnzz.com) ```站点设置```, ```获取代码``` 选择其中一种，并复制代码  
如图：
&lt;img src="http://localhost:2368/content/images/2016/02/-----2016-02-14---12-54-11.png" alt="duoshuo_setting"&gt;


3， 终端输入命令```npm start```开启服务&lt;br&gt;  
4， 浏览器输入 [http://localhost:2368/ghost](http://localhost:2368/ghost)进入后台管理。&lt;br&gt;  
5. 点击左侧边栏：```插入代码```，将复制的代码粘贴在```页脚```框中，保存。&lt;br&gt;&lt;br&gt;


至此，你的博客就有了基本完整的功能了，你可以登录多说和[CNZZ](http://www.cnzz.com)管理你的站点。


**如有遗漏，欢迎指正。谢谢。**



&lt;h3 id=""&gt;&lt;strong&gt;使用中遇到的问题&lt;/strong&gt;&lt;/h3&gt;

使用RSS阅读器：NewsBlur，遇到的问题：

&lt;ol&gt;
&lt;li&gt;搜索关键字"iOneWay"，无法搜索到我的博客RSS源地址。  &lt;/li&gt;
&lt;li&gt;手动添加“&lt;a href="http://ioneway.github.io/rss/index.rss”后，在列表中不显示图标icon"&gt;http://ioneway.github.io/rss/index.rss”后，在列表中不显示图标icon&lt;/a&gt;.  &lt;/li&gt;
&lt;li&gt;点击进去，阅读文章，发现文章中图片不显示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对RSS丝毫不懂，有哪位网友可以解答一下。&lt;/p&gt;</content:encoded></item></channel></rss>